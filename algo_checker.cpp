{
	"template":
	{
		"prefix": ["te"],
		"body":
		[
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"typedef long long int ll;",
			"typedef long double ld;",
			"#define pb push_back",
			"#define pf push_front",
			"#define fi first",
			"#define se second",
			"const ll mod = 1e9+7;",
			"signed main()",
			"{",
			" 	ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
			"	freopen(\"test.inp\",\"r\",stdin); freopen(\"test.out\",\"w\",stdout); freopen(\"test.err\",\"w\",stderr);",
			" ",	
			"}"
		]
	}
	// Data Structure
		// Segment Tree
		"st_min":
		{
			"prefix": ["st_min"],
			"body":
			[
				"struct segment_tree",
				"{",
				"    ll st[mxn<<2];",
				"    void update(ll id, ll l, ll r, ll u, ll x)",
				"    {",
				"        if (r < u || u < l) return;",
				"        if (l == r)",
				"        {",
				"            st[id] = (st[id]+x);",
				"            return;",
				"        }",
				"        ll m = (r+l)>>1;",
				"        update(id<<1,l,m,u,x); update(id<<1|1,m+1,r,u,x);",
				"        st[id] = min(st[id<<1],st[id<<1|1]);",
				"    }",
				"    ll get(ll id, ll l, ll r, ll u, ll v)",
				"    {",
				"        if (r < u || v < l) return 1e18;",
				"        if (u <= l && r <= v) return st[id];",
				"        ll m = (r+l)>>1;",
				"        return min(get(id<<1,l,m,u,v),get(id<<1|1,m+1,r,u,v));",
				"    }",
				"};"				
			]
		}
		"xor_basis":
		{
			"prefix": ["xor_basis"],
			"body":
			[
				"struct xor_basis",
				"{",
				"    vector<ll> basis;",
				"    void add(ll x)",
				"    {",
				"        for (ll i : basis) x = min(x, x^i);",
				"        if (x) basis.pb(x); ",
				"    }",
				"    bool ck(ll x)",
				"    {",
				"        for (ll i : basis) x = min(x, x^i);",
				"        return (x ? 1 : 0);",
				"    }",
				"};"	
			]
		}
		"xor_basis_2":
		{
			"prefix": ["xor_basis_2"],
			"body":
			[
				"struct xor_basis",
				"{",
				"    vector<ll> basis; ll sz = 0, nbit = 60;",
				"    xor_basis() {basis.resize(60);}",
				"    xor_basis(ll bit) {basis.resize(bit); nbit = bit;}",
				"    void add(ll x)",
				"    {",
				"        for (ll i = nbit-1; i >= 0; i--)",
				"        {",
				"            if (!(x>>i&1)) continue;",
				"            if (!basis[i]) {basis[i] = x; sz++; return;}",
				"            x ^= basis[i];    ",
				"        }",
				"    }",
				"    bool ck(ll x)",
				"    {",
				"        for (ll i = nbit-1; i >= 0; i--)",
				"        {",
				"            if (!(x>>i&1)) continue;",
				"            if (!basis[i]) {return 0;}",
				"            x ^= basis[i];    ",
				"        }",
				"        return 1;",
				"    }",
				"    ll kth(ll x)",
				"    {",
				"        ll ans = 0, t = 1LL<<sz;",
				"        for (ll i = nbit-1; i >= 0; i--)",
				"        {",
				"            if (basis[i])",
				"            {",
				"                ll l = t>>1;",
				"                if ((l < x && !(ans>>i&1)) || (l >= x && (ans>>i&1))) ans ^= basis[i];",
				"                if (l < x) x -= l;",
				"                t >>= 1;",
				"            }",
				"        }",
				"        return ans;",
				"    }",
				"};"
			]
		}
		"kth_lichao":
		{
			"prefix": ["kth_lichao"],
			"body":
			[
				"struct lichao_segment_tree",
				"{",
				"    static const ll l = -1e9, r = 1e9, inf = 1e18;",
				"    ll k;",
				"    struct line ",
				"    {",
				"        ll a, b; line() {} line(ll a, ll b) : a(a), b(b) {} ",
				"        ll operator() (ll x) {return a*x+b;}",
				"    };",
				"    struct node {vector<line> v; ll left = -1, right = -1;};",
				"    vector<node> v;",
				"    lichao_segment_tree() {v.clear(); v.emplace_back();}",
				"    lichao_segment_tree(ll kk) {v.clear(); v.emplace_back(); k = kk;}",
				"    void q_add(ll l, ll r, line nw, ll id = 0)",
				"    {",
				"        if (v[id].v.size() < 2*k-1) {v[id].v.pb(nw); return;}",
				"        ll m = (r+l)>>1;",
				"        v[id].v.pb(nw); ",
				"        nth_element(v[id].v.begin(),v[id].v.begin()+2*k-2,v[id].v.end(),[&](line a, line b) {return a(m) < b(m);});",
				"        line worst = v[id].v.back(); v[id].v.pop_back();",
				"        if (l == r) return;",
				"        ll cnt = 0;",
				"        for (line i : v[id].v)",
				"        {",
				"            bool side = worst(l) < i(l);",
				"            cnt += side; cnt -= (!side);",
				"        }",
				"        if (cnt >= 0) ",
				"        {",
				"            if (v[id].left == -1) {v[id].left = v.size(); v.emplace_back();} ",
				"            q_add(l, m, worst, v[id].left);",
				"        }",
				"        else ",
				"        {",
				"            if (v[id].right == -1) {v[id].right = v.size(); v.emplace_back();} ",
				"            q_add(m+1, r, worst, v[id].right);",
				"        }",
				"    }",
				"    void q_get(ll l, ll r, ll x, ll id, vector<ll> &ans)",
				"    {",
				"        for (line i : v[id].v) ans.pb(i(x));",
				"        if (l == r) return;",
				"        ll m = (r+l)>>1;",
				"        if (x <= m && v[id].left != -1) q_get(l,m,x,v[id].left,ans);",
				"        if (x > m && v[id].right != -1) q_get(m+1,r,x,v[id].right,ans); ",
				"    }",
				"    void add(ll a, ll b) {q_add(l, r, {a, b});}",
				"    ll get(ll x)",
				"    {",
				"        vector<ll> ans; q_get(l, r, x, 0, ans);",
				"        nth_element(ans.begin(), ans.begin()+k-1, ans.end());",
				"        return ans[k-1];",
				"    }   ",
				"} st;"				
			]
		}
		"lazy_lichao":
		{
			"prefix": ["lazy_lichao"],
			"body":
			[
				"struct lazy_lichao_segment_tree",
				"{",
				"    static const ll l_l = -1e9, r_r = 1e9;",
				"    struct line",
				"    {",
				"        ll a, b;",
				"        line() {a = 0; b = -1e18;}",
				"        line(ll aa, ll bb) {a = aa; b = bb;}",
				"        ll operator() (ll x) {return a*x+b;}",
				"        void add(line x) {a += x.a; b += x.b;}",
				"    };",
				"    struct node",
				"    {",
				"        line opt, lz = line(0,0);",
				"        node *right = nullptr, *left = nullptr;",
				"        void upd(line v) {opt.add(v); lz.add(v);}",
				"    };",
				"    node *root;",
				"    void push_lazy(node* &n)",
				"    {",
				"        if (n == nullptr) return;",
				"        if ((*n).left == nullptr) (*n).left = new node();",
				"        if ((*n).right == nullptr) (*n).right = new node();",
				"        (*((*n).left)).upd((*n).lz); (*((*n).right)).upd((*n).lz);",
				"        (*n).lz = line(0,0);",
				"    }",
				"    void push_line(node* &n, ll l, ll r)",
				"    {",
				"        if (n == nullptr) return;",
				"        ll m = (r+l)>>1;",
				"        insert_opt_line((*n).left, l, m, (*n).opt);",
				"        insert_opt_line((*n).right, m+1, r, (*n).opt);",
				"        (*n).opt = line();",
				"    }",
				"    void insert_opt_line(node* &n, ll l, ll r, line x)",
				"    {",
				"        if (n == nullptr) n = new node();",
				"        if ((*n).opt(l) < x(l)) swap((*n).opt,x);",
				"        if ((*n).opt(r) >= x(r)) return;",
				"        if (l == r) return;",
				"        ll m = (r+l)>>1; push_lazy(n);",
				"        if ((*n).opt(m) > x(m)) insert_opt_line((*n).right, m+1, r, x);",
				"        else {swap((*n).opt,x); insert_opt_line((*n).left, l, m, x);}",
				"    }",
				"    void insert_line(node* &n, ll l, ll r, ll u, ll v, line x)",
				"    {",
				"        if (r < u || v < l || l > r || u > v) return;",
				"        if (n == nullptr) n = new node();",
				"        if (u <= l && r <= v) return insert_opt_line(n, l, r, x);",
				"        ll m = (r+l)>>1; push_lazy(n);",
				"        insert_line((*n).left, l, m, u, v, x);",
				"        insert_line((*n).right, m+1, r, u, v, x);",
				"    }",
				"    void add_line(node* &n, ll l, ll r, ll u, ll v, line x)",
				"    {",
				"        if (r < u || v < l || l > r || u > v) return;",
				"        if (n == nullptr) n = new node();",
				"        if (u <= l && r <= v) return (*n).upd(x);",
				"        ll m = (r+l)>>1; push_lazy(n); push_line(n, l, r);",
				"        add_line((*n).left, l, m, u, v, x);",
				"        add_line((*n).right, m+1, r, u, v, x);",
				"    }",
				"    ll query(node* &n, ll l, ll r, ll x)",
				"    {",
				"        if (n == nullptr) return -(ll)1e18;",
				"        if (l == r) return (*n).opt(x);",
				"        ll ans = (*n).opt(x), m = (r+l)>>1; push_lazy(n);",
				"        if (x <= m) ans = max(ans, query((*n).left, l, m, x));",
				"        else ans = max(ans, query((*n).right, m+1, r, x));",
				"        return ans;",
				"    }",
				"    void insert(ll l, ll r, line x) {return insert_line(root, l_l, r_r, l, r, x);}",
				"    void add(ll l, ll r, line x) {return add_line(root, l_l, r_r, l, r, x);}",
				"    ll query(ll x) {return query(root, l_l, r_r, x);}",
				"} st;"
			]
		}
		"suffix_array":
		{
			"prefix": ["sa"],
			"body":
			[
				"struct suffix_array",
				"{",
				"    ll n; string s;",
				"    vector<pair<pair<ll,ll>,ll>> suffs;",
				"    vector<ll> lcp, suffs_id;",
				"    suffix_array() {}",
				"    suffix_array(string ss) {s = ss; s += '$'; n = s.size(); suffs.resize(n);}",
				"    void get_string() {cin >> s; s += '$'; n = s.size(); suffs.resize(n);}",
				"    void radix_sort(vector<pair<pair<ll,ll>,ll>> &arr)",
				"    {",
				"        for (ll i : vector<ll>{2,1})",
				"        {",
				"            auto key = [&](const pair<pair<ll,ll>,ll> &x) {return (i == 1) ? x.fi.fi : x.fi.se;};",
				"            ll mx = 0;",
				"            for (const pair<pair<ll,ll>,ll> &i : arr) mx = max(mx,key(i));",
				"            vector<ll> occs(mx+1);",
				"            for (const pair<pair<ll,ll>,ll> &i : arr) occs[key(i)]++;",
				"            vector<ll> start(mx+1);",
				"            for (ll i = 1; i <= mx; i++) start[i] = start[i-1]+occs[i-1];",
				"            vector<pair<pair<ll,ll>,ll>> new_arr(arr.size());",
				"            for (const pair<pair<ll,ll>,ll> &i : arr) ",
				"            {",
				"                new_arr[start[key(i)]] = i;",
				"                start[key(i)]++;",
				"            }",
				"            arr = new_arr;",
				"        }",
				"    }",
				"    void build_sa()",
				"    {",
				"        for (ll i = 0; i < n; i++) suffs[i] = {{s[i],s[i]},i};",
				"        sort(suffs.begin(),suffs.end());",
				"        vector<ll> equiv(n);",
				"        for (ll i = 1; i < n; i++)",
				"        {",
				"            pair<pair<ll,ll>,ll> curr = suffs[i], last = suffs[i-1];",
				"            equiv[curr.se] = equiv[last.se]+(curr.fi > last.fi);",
				"        }",
				"        for (ll i = 1; i < n; i<<=1)",
				"        {",
				"            for (pair<pair<ll,ll>,ll> &j : suffs) j.fi = {equiv[j.se], equiv[(j.se+i)%n]};",
				"            radix_sort(suffs);",
				"            for (ll j = 1; j < n; j++)",
				"            {",
				"                pair<pair<ll,ll>,ll> curr = suffs[j], last = suffs[j-1];",
				"                equiv[curr.se] = equiv[last.se]+(curr.fi > last.fi);",
				"            }",
				"        }",
				"    }",
				"    void build_lcp()",
				"    {",
				"        lcp.resize(n-1); suffs_id.resize(n);",
				"        for (ll i = 0; i < n; i++) suffs_id[suffs[i].se] = i;",
				"        ll start_at = 0;",
				"        for (ll i = 0; i < n-1; i++)",
				"        {",
				"            ll prv = suffs[suffs_id[i]-1].se;",
				"            ll curr = start_at;",
				"            while (s[i+curr] == s[prv+curr]) curr++;",
				"            lcp[suffs_id[i]-1] = curr;",
				"            start_at = max(curr-1,0LL);",
				"        }",
				"    }",
				"    ll diff_str()",
				"    {",
				"        ll diff = 0;",
				"        for (ll i = 0; i < lcp.size(); i++) diff += n-i-lcp[i]-1;",
				"        return diff;",
				"    }",
				"};"											
			]
		}
		"bridge_tree":
		{
			"prefix": ["bt"],
			"body":
			[
				"struct bridge_tree",
				"{",
				"    ll n, m, tdfs, cnt;",
				"    vector<ll> tin, comp, low;",
				"    vector<bool> used, is_bridge;",
				"    vector<vector<pair<ll,ll>>> g;",
				"    vector<vector<ll>> b_tree;",
				"    vector<pair<ll,ll>> ed;",
				"    bridge_tree() {}",
				"    bridge_tree(ll nn, ll mm)",
				"    {",
				"        n = nn; m = mm;",
				"        tdfs = cnt = 0;",
				"        tin.resize(n+7); comp.resize(n+7); low.resize(n+7);",
				"        used.resize(n+7); is_bridge.resize(m+7);",
				"        g.resize(n+7); b_tree.resize(n+7); ed.resize(m+7);",
				"    }",
				"    void get_tree()",
				"    {",
				"        for (ll i = 1; i <= m; i++)",
				"        {",
				"            ll a, b; cin >> a >> b;",
				"            g[a].pb({b,i}); g[b].pb({a,i});",
				"            ed[i] = {a,b};",
				"        }",
				"    }",
				"    void dfs(ll u, ll v)",
				"    {",
				"        tin[u] = low[u] = ++tdfs;",
				"        used[u] = 1;",
				"        for (pair<ll,ll> i : g[u])",
				"        {",
				"            if (i.fi != v)",
				"            {",
				"                if (used[i.fi]) low[u] = min(low[u], tin[i.fi]);",
				"                else",
				"                {",
				"                    dfs(i.fi, u);",
				"                    low[u] = min(low[u], low[i.fi]);",
				"                    if (low[i.fi] > tin[u]) is_bridge[i.se] = 1;",
				"                }",
				"            }",
				"        }",
				"    }",
				"    void decompose(ll u, ll v)",
				"    {",
				"        used[u] = 1; comp[u] = cnt;",
				"        for (pair<ll,ll> i : g[u]) if (!is_bridge[i.se] && !used[i.fi]) decompose(i.fi,u);",
				"    }",
				"    void build()",
				"    {",
				"        get_tree(); dfs(1,1);",
				"        for (ll i = 1; i <= n; i++) used[i] = 0;",
				"        for (ll i = 1; i <= n; i++) if (!used[i]) {cnt++; decompose(i,i);}",
				"        for (ll i = 1; i <= m; i++)",
				"        {",
				"            if (is_bridge[i])",
				"            {",
				"                b_tree[comp[ed[i].fi]].pb(comp[ed[i].se]);",
				"                b_tree[comp[ed[i].se]].pb(comp[ed[i].fi]);",
				"            }",
				"        }",
				"        g.clear(); ed.clear(); used.clear(); is_bridge.clear(); ",
				"        tin.clear(); comp.clear(); low.clear(); ",
				"    }",
				"};"												
			]
		}
		"block_cut_tree":
		{
			"prefix": ["bct"],
			"body":
			[
				"struct block_cut_tree",
				"{",
				"    ll n, m, tdfs = 0, node_id = 0;",
				"    vector<ll> num, low, id;",
				"    vector<bool> is_cutpoint;",
				"    vector<vector<ll>> c, start_g, g;  ",
				"    stack<ll> stk;",
				"    block_cut_tree() {}",
				"    block_cut_tree(ll nn, ll mm) ",
				"    {",
				"        n = nn; m = mm;",
				"        start_g.resize(n+7); num.resize(n+7); ",
				"        low.resize(n+7); is_cutpoint.resize(n+7);",
				"        id.resize(n+7);",
				"    }",
				"    void get_graph()",
				"    {",
				"        for (ll i = 1; i <= m; i++)",
				"        {",
				"            ll a, b; cin >> a >> b;",
				"            start_g[a].pb(b); start_g[b].pb(a);",
				"        }",
				"    }",
				"    void find_2cc(ll u, ll v)",
				"    {",
				"        num[u] = low[u] = ++tdfs; stk.push(u);",
				"        for (ll i : start_g[u])",
				"        {",
				"            if (i != v)",
				"            {",
				"                if (!num[i])",
				"                {",
				"                    find_2cc(i,u);",
				"                    low[u] = min(low[u],low[i]);",
				"                    if (low[i] >= num[u])",
				"                    {",
				"                        is_cutpoint[u] = (num[u] > 1 || num[i] > 2);",
				"                        c.pb({u}); while (c.back().back() != i) c.back().pb(stk.top()), stk.pop();",
				"                    }",
				"                } ",
				"                else low[u] = min(low[u],num[i]);",
				"            }",
				"        }",
				"    }",
				"    void build()",
				"    {",
				"        for (ll i = 1; i <= n; i++) {if (!num[i]) {find_2cc(i,i);}} g.pb({});",
				"        for (ll i = 1; i <= n; i++) {if (is_cutpoint[i]) {id[i] = ++node_id; g.pb({});}}",
				"        for (vector<ll> i : c)",
				"        {",
				"            ll node = ++node_id; g.pb({});",
				"            for (ll u : i)",
				"            {",
				"                if (!is_cutpoint[u]) id[u] = node;",
				"                else {g[node].pb(id[u]), g[id[u]].pb(node);}",
				"            }",
				"        }",
				"    }",
				"};"												
			]
		}
		"cumbi":
		{
			"prefix": ["combi"],
			"body":
			[
				"    for (ll i = 1; i <= 500; i++)",
				"    {",
				"        c[1][i] = i;",
				"        for (ll j = 2; j <= i; j++)",
				"        {",
				"            c[j][i] = c[j-1][i-1]+c[j][i-1];",
				"            c[j][i] %= mod;",
				"        }",
				"    }   "							
			]
		}
		"pragma":
		{
			"prefix": ["pragma"],
			"body":
			[
				"#pragma GCC optimize(\"Ofast,unroll-loops\")",
				"#pragma GCC target(\"arch=skylake\")"						
			]
		}
		"tester":
		{
			"prefix": ["tester"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long int ll;",
				"const string NAME = \"tester\";",
				"const string name = \"test\";",
				"const int NTEST = 1000;",
				"mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());",
				"#define rand rd",
				"long long Rand(long long l, long long h) ",
				"{",
				"    assert(l <= h);",
				"    return l + rd() % (h - l + 1);",
				"}",
				"int main()",
				"{",
				"    srand(time(NULL));",
				"    ll cnt = 0;",
				"    for (int iTest = 1; iTest <= NTEST; iTest++)",
				"    {",
				"        ofstream inp((name + \".inp\").c_str());",
				"		inp.close();",
				"        system((NAME + \".exe\").c_str());",
				"        system((NAME + \"_ans.exe\").c_str());",
				"        if (system((\"fc \" + name + \".out \" + name + \".ans\").c_str()) != 0)",
				"        {",
				"            cout << \"Test \" << iTest << \": WA!\" << endl;",
				"            return 0;",
				"        }",
				"        else",
				"        {",
				"            cout << \"Test \" << iTest << \": AC!\" << endl;",	
				"            cnt++;",
				"        }",
				"    }",
				"    cout << \"FINAL SCORE: \" << cnt << \" / \" << NTEST;",
				"    return 0;",
				"}"
			]
		}
		"linux_tester":
		{
			"prefix": ["linux_tester"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long int ll;",
				"const string NAME = \"stress_test_tester\";",
				"const string name = \"test\";",
				"const int NTEST = 100;",
				"mt19937 rd(chrono::steady_clock::now().time_since_epoch().count());",
				"#define rand rd",
				"long long Rand(long long l, long long h) ",
				"{",
				"    assert(l <= h);",
				"    return l + rd() % (h - l + 1);",
				"}",
				"int main()",
				"{",
				"    srand(time(NULL));",
				"    ll cnt = 0;",
				"    for (int iTest = 1; iTest <= NTEST; iTest++)",
				"    {",
				"        ofstream inp((name + \".inp\").c_str());",
				"        inp.close();",
				"        system((\"./\" + NAME).c_str());",
				"        system((\"./\" + NAME + \"_ans\").c_str());",
				"        if (system((\"diff \" + name + \".out \" + name + \".ans\").c_str()) != 0)",
				"        {",
				"            cout << \"Test \" << iTest << \": WA\" << endl;",
				"            // return 0;",
				"        }",
				"        else",
				"        {",
				"            cout << \"Test \" << iTest << \": AC\" << endl;",
				"            cnt++;",
				"        }",
				"    }",
				"    cout << \"FINAL SCORE: \" << cnt << \" / \" << NTEST << endl;",
				"    return 0;",
				"}"
			]
		}
		"gauss":
		{
			"prefix": ["gauss"],
			"body":
			[
				"const double eps = 1e-9;",
				"ll gauss(vector<vector<double>> a, vector<double>& ans)",
				"{",
				"    ll n = (ll)a.size(), m = (ll)(a[0].size()-1);",
				"    vector<ll> where(m, -1);",
				"    for (ll col = 0, row = 0; col < m && row < n; col++, row++)",
				"    {",
				"        ll sel = row;",
				"        for (ll i = row; i < n; i++) if (abs(a[i][col]) > abs(a[sel][col])) sel = i;",
				"        if (abs(a[sel][col]) < eps) continue;",
				"        for (ll i = col; i <= m; i++) swap(a[sel][i], a[row][i]);",
				"        where[col] = row;",
				"        for (ll i = 0; i < n; i++) ",
				"        {",
				"            if (i != row)",
				"            {",
				"                double c = a[i][col] / a[row][col];",
				"                for (ll j = col; j <= m; j++) a[i][j] -= a[row][j]*c;",
				"            }",
				"        }",
				"    }",
				"    ans.assign(m, 0);",
				"    for (ll i = 0; i < m; i++) if (where[i] != -1) ans[i] = a[where[i]][m] / a[where[i]][i];",
				"    for (ll i = 0; i < n; i++)",
				"    {",
				"        double sum = 0;",
				"        for (ll j = 0; j < m; j++) sum += ans[j]*a[i][j];",
				"        if (abs(sum-a[i][m]) > eps) return 0;",
				"    }",
				"    for (ll i = 0; i < m; i++) if (where[i] == -1) return 2;",
				"    return 1;",
				"}"						
			]
		}
		"st_dyna":
		{
			"prefix": ["st_dyna"],
			"body":
			[
				"struct dynamic_segment_tree",
				"{",
				"    struct node {ll v, l, r; node() {v = 0; l = -1, r = -1;}};",
				"    vector<node> st;",
				"    dynamic_segment_tree() {st.clear(); st.pb(node());};",
				"    void update(ll id, ll l, ll r, ll i, ll x)",
				"    {",
				"        if (l == r) {st[id].v += x; return;}",
				"        ll m = (r+l)>>1; st[id].v += x;",
				"        if (l <= i && i <= m)",
				"        {",
				"            if (st[id].l == -1) {st[id].l = st.size(); st.pb(node());}",
				"            update(st[id].l,l,m,i,x);",
				"        }",
				"        if (m < i && i <= r)",
				"        {",
				"            if (st[id].r == -1) {st[id].r = st.size(); st.pb(node());}",
				"            update(st[id].r,m+1,r,i,x);",
				"        }",
				"    }",
				"    ll get(ll id, ll l, ll r, ll u, ll v)",
				"    {",
				"        if (r < u || v < l) return 0;",
				"        if (u <= l && r <= v) return st[id].v;",
				"        ll m = (r+l)>>1, val = 0;",
				"        if (st[id].l != -1) val += get(st[id].l,l,m,u,v);",
				"        if (st[id].r != -1) val += get(st[id].r,m+1,r,u,v);",
				"        return val;",
				"    }",
				"    void update(ll i, ll x) {update(0,-1e15,1e15,i,x);}",
				"    ll get(ll u, ll v) {return get(0,-1e15,1e15,u,v);}",
				"} st;"					
			]
		}
		"lichao_min":
		{
			"prefix": ["lichao_min"],
			"body":
			[
				"struct lichao_segment_tree",
				"{",
				"    static const ll l = -1e9, r = 1e9, inf = 1e18;",
				"    struct line ",
				"    {",
				"        ll a, b; line() {} line(ll a, ll b) : a(a), b(b) {} ",
				"        ll operator() (ll x) {return a*x+b;}",
				"    };",
				"    struct node",
				"    {",
				"        line y = line(0, inf);",
				"        node *left = nullptr, *right = nullptr;",
				"        void add(ll l, ll r, line nw)",
				"        {",
				"            ll m = (r+l)>>1;",
				"            bool lef = y(l) > nw(l), mid = y(m) > nw(m), rig = y(r) > nw(r);",
				"            if (mid) swap(nw, y);",
				"            if (l == r) return;",
				"            else if (lef != mid) {if (!left) {left = new node;} (*left).add(l, m, nw);}",
				"            else if (rig != mid) {if (!right) {right = new node;} (*right).add(m+1, r, nw);}",
				"        }",
				"        ll get(ll l, ll r, ll x)",
				"        {",
				"            ll m = (r+l)>>1, val = y(x);",
				"            if (x < m && left) val = min(val, (*left).get(l, m, x));",
				"            if (x > m && right) val = min(val, (*right).get(m+1, r, x));",
				"            return val; ",
				"        }",
				"    } st;",
				"    void add(ll a, ll b) {st.add(l, r, {a, b});}",
				"    ll get(ll x) {return st.get(l, r, x);}",
				"} st;"										
			]
		}
		"lichao_max":
		{
			"prefix": ["lichao_max"],
			"body":
			[
				"struct lichao_segment_tree",
				"{",
				"    static const ll l = -1e9, r = 1e9, inf = 1e18;",
				"    struct line ",
				"    {",
				"        ll a, b; line() {} line(ll a, ll b) : a(a), b(b) {} ",
				"        ll operator() (ll x) {return a*x+b;}",
				"    };",
				"    struct node",
				"    {",
				"        line y = line(0, 0);",
				"        node *left = nullptr, *right = nullptr;",
				"        void add(ll l, ll r, line nw)",
				"        {",
				"            ll m = (r+l)>>1;",
				"            bool lef = y(l) < nw(l), mid = y(m) < nw(m), rig = y(r) < nw(r);",
				"            if (mid) swap(nw, y);",
				"            if (l == r) return;",
				"            else if (lef != mid) {if (!left) {left = new node;} (*left).add(l, m, nw);}",
				"            else if (rig != mid) {if (!right) {right = new node;} (*right).add(m+1, r, nw);}",
				"        }",
				"        ll get(ll l, ll r, ll x)",
				"        {",
				"            ll m = (r+l)>>1, val = y(x);",
				"            if (x < m && left) val = max(val, (*left).get(l, m, x));",
				"            if (x > m && right) val = max(val, (*right).get(m+1, r, x));",
				"            return val; ",
				"        }",
				"    } st;",
				"    void add(ll a, ll b) {st.add(l, r, {a, b});}",
				"    ll get(ll x) {return st.get(l, r, x);}",
				"} st;"													
			]
		}
		"lichao_max_2":
		{
			"prefix": ["lichao_max_2"],
			"body":
			[
				"struct lichao_segment_tree",
				"{",
				"    static const ll l = -1e9, r = 1e9, inf = 1e18;",
				"    struct line ",
				"    {",
				"        ll a, b; line() {} line(ll a, ll b) : a(a), b(b) {} ",
				"        ll operator() (ll x) {return a*x+b;}",
				"    };",
				"    struct node {line y = line(0, 0); ll left = -1, right = -1;};",
				"    vector<node> v;",
				"    lichao_segment_tree() {v.clear(); v.emplace_back();}",
				"    void q_add(ll l, ll r, line nw, ll id = 0)",
				"    {",
				"        ll m = (r+l)>>1;",
				"        bool lef = v[id].y(l) < nw(l), mid = v[id].y(m) < nw(m), rig = v[id].y(r) < nw(r);",
				"        if (mid) swap(nw, v[id].y);",
				"        if (l == r) return;",
				"        else if (lef != mid) {if (v[id].left == -1) {v[id].left = v.size(); v.emplace_back();} q_add(l, m, nw, v[id].left);}",
				"        else if (rig != mid) {if (v[id].right == -1) {v[id].right = v.size(); v.emplace_back();} q_add(m+1, r, nw, v[id].right);}",
				"    }",
				"    ll q_get(ll l, ll r, ll x, ll id = 0)",
				"    {",
				"        ll m = (r+l)>>1, val = v[id].y(x);",
				"        if (x < m && v[id].left != -1) val = max(val, q_get(l, m, x, v[id].left));",
				"        if (x > m && v[id].right != -1) val = max(val, q_get(m+1, r, x, v[id].right));",
				"        return val;",
				"    }",
				"    void add(ll a, ll b) {q_add(l, r, {a, b});}",
				"    ll get(ll x) {return q_get(l, r, x);}",
				"} st;"																
			]
		}
		"lichao_min_2":
		{
			"prefix": ["lichao_min_2"],
			"body":
			[
				"struct lichao_segment_tree",
				"{",
				"    static const ll l = -1e9, r = 1e9, inf = 1e18;",
				"    struct line ",
				"    {",
				"        ll a, b; line() {} line(ll a, ll b) : a(a), b(b) {} ",
				"        ll operator() (ll x) {return a*x+b;}",
				"    };",
				"    struct node {line y = line(0, inf); ll left = -1, right = -1;};",
				"    vector<node> v;",
				"    lichao_segment_tree() {v.clear(); v.emplace_back();}",
				"    void q_add(ll l, ll r, line nw, ll id = 0)",
				"    {",
				"        ll m = (r+l)>>1;",
				"        bool lef = v[id].y(l) > nw(l), mid = v[id].y(m) > nw(m), rig = v[id].y(r) > nw(r);",
				"        if (mid) swap(nw, v[id].y);",
				"        if (l == r) return;",
				"        else if (lef != mid) {if (v[id].left == -1) {v[id].left = v.size(); v.emplace_back();} q_add(l, m, nw, v[id].left);}",
				"        else if (rig != mid) {if (v[id].right == -1) {v[id].right = v.size(); v.emplace_back();} q_add(m+1, r, nw, v[id].right);}",
				"    }",
				"    ll q_get(ll l, ll r, ll x, ll id = 0)",
				"    {",
				"        ll m = (r+l)>>1, val = v[id].y(x);",
				"        if (x < m && v[id].left != -1) val = min(val, q_get(l, m, x, v[id].left));",
				"        if (x > m && v[id].right != -1) val = min(val, q_get(m+1, r, x, v[id].right));",
				"        return val;",
				"    }",
				"    void add(ll a, ll b) {q_add(l, r, {a, b});}",
				"    ll get(ll x) {return q_get(l, r, x);}",
				"} st;"																			
			]
		}
		"convex_hull_trick":
		{
			"prefix": ["cht"],
			"body":
			[
				"struct convex_hull_trick",
				"{",
				"    static const ll inf = 1e18;",
				"    struct line ",
				"    {",
				"        mutable ll k, m, p;",
				"        bool operator < (const line& o) const {return k < o.k;}",
				"        bool operator < (ll x) const {return p < x;}",
				"    };",
				"    struct line_container : multiset<line, less<>>",
				"    {",
				"        ll div(ll a, ll b) {return a/b-((a^b)<0&&a%b);}",
				"        bool intersect(iterator x, iterator y)",
				"        {",
				"            if (y == end()) return (*x).p = inf, 0;",
				"            if ((*x).k == (*y).k) (*x).p = ((*x).m > (*y).m ? inf : -inf);",
				"            else (*x).p = div((*y).m-(*x).m, (*x).k-(*y).k);",
				"            return (*x).p >= (*y).p;",
				"        }",
				"        void add(ll k, ll m)",
				"        {",
				"            multiset<line>::iterator z = insert({k, m, 0}), y = z++, x = y;",
				"            while (intersect(y, z)) z = erase(z);",
				"            if (x != begin() && intersect(--x, y)) intersect(x, y = erase(y));",
				"            while ((y = x) != begin() && (*(--x)).p >= (*y).p) intersect(x, erase(y));",
				"        }",
				"        ll query(ll x) {if (empty()) {return LLONG_MIN;} line l = *lower_bound(x); return l.k*x+l.m;}",
				"    };",
				"    line_container cht[mxn<<2];",
				"    void update(ll id, ll l, ll r, ll u, ll v, pair<ll,ll> p)",
				"    {",
				"        if (r < u || v < l) return;",
				"        if (u <= l && r <= v) {cht[id].add(p.fi, p.se); return;}",
				"        ll m = (r+l)>>1; update(id<<1,l,m,u,v,p); update(id<<1|1,m+1,r,u,v,p);",
				"    }",
				"    ll get(ll id, ll l, ll r, ll p, ll x)",
				"    {",
				"        if (l == r) {return cht[id].query(x);} ll m = (r+l)>>1;",
				"        if (p <= m) return max(cht[id].query(x), get(id<<1,l,m,p,x));",
				"        else return max(cht[id].query(x), get(id<<1|1,m+1,r,p,x));",
				"    }",
				"} st;"												
			]
		}
		"time_lichao_max":
		{
			"prefix": ["lichao_time_max"],
			"body":
			[
				"struct time_lichao_segment_tree",
				"{",
				"    struct lichao_segment_tree",
				"    {",
				"        static const ll l = -1e9, r = 1e9, inf = LLONG_MIN;",
				"        struct line ",
				"        {",
				"            ll a, b; line() {} line(ll a, ll b) : a(a), b(b) {} ",
				"            ll operator() (ll x) {return a*x+b;}",
				"        };",
				"        struct node {line y = line(0, inf); ll left = -1, right = -1;};",
				"        vector<node> v;",
				"        lichao_segment_tree() {v.clear(); v.emplace_back();}",
				"        void q_add(ll l, ll r, line nw, ll id = 0)",
				"        {",
				"            ll m = (r+l)>>1;",
				"            bool lef = v[id].y(l) < nw(l), mid = v[id].y(m) < nw(m), rig = v[id].y(r) < nw(r);",
				"            if (mid) swap(nw, v[id].y);",
				"            if (l == r) return;",
				"            else if (lef != mid) {if (v[id].left == -1) {v[id].left = v.size(); v.emplace_back();} q_add(l, m, nw, v[id].left);}",
				"            else if (rig != mid) {if (v[id].right == -1) {v[id].right = v.size(); v.emplace_back();} q_add(m+1, r, nw, v[id].right);}",
				"        }",
				"        ll q_get(ll l, ll r, ll x, ll id = 0)",
				"        {",
				"            ll m = (r+l)>>1, val = v[id].y(x);",
				"            if (x < m && v[id].left != -1) val = max(val, q_get(l, m, x, v[id].left));",
				"            if (x > m && v[id].right != -1) val = max(val, q_get(m+1, r, x, v[id].right));",
				"            return val;",
				"        }",
				"        void add(ll a, ll b) {q_add(l, r, {a, b});}",
				"        ll get(ll x) {return q_get(l, r, x);}",
				"    } st[mxn<<2];",
				"    void update(ll id, ll l, ll r, ll u, ll v, pair<ll,ll> line)",
				"    {",
				"        if (r < u || v < l) return;",
				"        if (u <= l && r <= v) {st[id].add(line.fi, line.se); return;}",
				"        ll m = (r+l)>>1;",
				"        update(id<<1,l,m,u,v,line); update(id<<1|1,m+1,r,u,v,line);",
				"    }",
				"    ll get(ll id, ll l, ll r, ll u, ll x)",
				"    {",
				"        if (l == r) {return st[id].get(x);} ll m = (r+l)>>1;",
				"        if (u <= m) return max(st[id].get(x), get(id<<1,l,m,u,x));",
				"        else return max(st[id].get(x), get(id<<1|1,m+1,r,u,x));",
				"    }",
				"} st;"								
			]
		}
		"st_persis":
		{
			"prefix": ["st_persis"],
			"body":
			[
				"struct persistent_segment_tree",
				"{",
				"    struct node ",
				"    {",
				"        ll v, l, r;",
				"        node() {l = r = -1;}",
				"        node(ll x) {v = x; l = r = -1;}",
				"    };",
				"    vector<node> st; vector<ll> time;",
				"    persistent_segment_tree() {st.clear(); st.emplace_back(); time.pb(0);}",
				"    void build(ll id, ll l, ll r, vector<ll>& v)",
				"    {",
				"        if (l == r) {st[id].v = v[l]; return;}",
				"        ll m = (r+l)>>1;",
				"        if (st[id].l == -1)",
				"        {",
				"            st[id].l = st.size();",
				"            st.emplace_back();",
				"            build(st[id].l,l,m,v);",
				"        } ",
				"        if (st[id].r == -1)",
				"        {",
				"            st[id].r = st.size();",
				"            st.emplace_back();",
				"            build(st[id].r,m+1,r,v);",
				"        }",
				"        st[id].v = st[st[id].l].v+st[st[id].r].v;",
				"    }",
				"    void update(ll id, ll l, ll r, ll i, ll x, ll cpy)",
				"    {",
				"        if (l == r) {st[id].v = x; return;}",
				"        ll m = (r+l)>>1; st[id] = st[cpy];",
				"        if (i <= m)",
				"        {",
				"            st[id].l = st.size();",
				"            st.emplace_back();",
				"            update(st[id].l,l,m,i,x,st[cpy].l);",
				"        }",
				"        else",
				"        {",
				"            st[id].r = st.size();",
				"            st.emplace_back();",
				"            update(st[id].r,m+1,r,i,x,st[cpy].r);",
				"        }",
				"        st[id].v = st[st[id].l].v+st[st[id].r].v;",
				"    }",
				"    void upd(ll l, ll r, ll i, ll x)",
				"    {",
				"        time.pb(st.size()); st.emplace_back();",
				"        update(time.back(),l,r,i,x,time[time.size()-2]);",
				"    }",
				"    ll get(ll id, ll l, ll r, ll u, ll v)",
				"    {",
				"        if (r < u || v < l) return 0;",
				"        if (u <= l && r <= v) return st[id].v;",
				"        ll m = (r+l)>>1;",
				"        return get(st[id].l,l,m,u,v)+get(st[id].r,m+1,r,u,v);",
				"    }",
				"} st;"
			]
		}
		"time_lichao_min":
		{
			"prefix": ["lichao_time_min"],
			"body":
			[
				"struct time_lichao_segment_tree",
				"{",
				"    struct lichao_segment_tree",
				"    {",
				"        static const ll l = -1e9, r = 1e9, inf = LLONG_MAX;",
				"        struct line ",
				"        {",
				"            ll a, b; line() {} line(ll a, ll b) : a(a), b(b) {} ",
				"            ll operator() (ll x) {return a*x+b;}",
				"        };",
				"        struct node {line y = line(0, inf); ll left = -1, right = -1;};",
				"        vector<node> v;",
				"        lichao_segment_tree() {v.clear(); v.emplace_back();}",
				"        void q_add(ll l, ll r, line nw, ll id = 0)",
				"        {",
				"            ll m = (r+l)>>1;",
				"            bool lef = v[id].y(l) > nw(l), mid = v[id].y(m) > nw(m), rig = v[id].y(r) > nw(r);",
				"            if (mid) swap(nw, v[id].y);",
				"            if (l == r) return;",
				"            else if (lef != mid) {if (v[id].left == -1) {v[id].left = v.size(); v.emplace_back();} q_add(l, m, nw, v[id].left);}",
				"            else if (rig != mid) {if (v[id].right == -1) {v[id].right = v.size(); v.emplace_back();} q_add(m+1, r, nw, v[id].right);}",
				"        }",
				"        ll q_get(ll l, ll r, ll x, ll id = 0)",
				"        {",
				"            ll m = (r+l)>>1, val = v[id].y(x);",
				"            if (x < m && v[id].left != -1) val = min(val, q_get(l, m, x, v[id].left));",
				"            if (x > m && v[id].right != -1) val = min(val, q_get(m+1, r, x, v[id].right));",
				"            return val;",
				"        }",
				"        void add(ll a, ll b) {q_add(l, r, {a, b});}",
				"        ll get(ll x) {return q_get(l, r, x);}",
				"    } st[mxn<<2];",
				"    void update(ll id, ll l, ll r, ll u, ll v, pair<ll,ll> line)",
				"    {",
				"        if (r < u || v < l) return;",
				"        if (u <= l && r <= v) {st[id].add(line.fi, line.se); return;}",
				"        ll m = (r+l)>>1;",
				"        update(id<<1,l,m,u,v,line); update(id<<1|1,m+1,r,u,v,line);",
				"    }",
				"    ll get(ll id, ll l, ll r, ll u, ll x)",
				"    {",
				"        if (l == r) {return st[id].get(x);} ll m = (r+l)>>1;",
				"        if (u <= m) return min(st[id].get(x), get(id<<1,l,m,u,x));",
				"        else return min(st[id].get(x), get(id<<1|1,m+1,r,u,x));",
				"    }",
				"} st;"							
			]
		}
		"dsu_rollback":
		{
			"prefix": ["dsu_rollback"],
			"body":
			[
				"struct dsu",
				"{",
				"    vector<ll> p, sz; vector<pair<ll&,ll>> history; ll cc;",
				"    dsu() {} dsu(ll n) : p(n+7), sz(n+7, 1), cc(n) {iota(p.begin(), p.end(), 0);}",
				"    ll fs(ll x) {return (x == p[x] ? x : fs(p[x]));}",
				"    void us(ll a, ll b)",
				"    {",
				"        a = fs(a); b = fs(b);",
				"        if (a == b) return;",
				"        if (sz[a] < sz[b]) swap(a, b);",
				"        history.pb({sz[a], sz[a]}); history.pb({p[b], p[b]});",
				"        p[b] = a; sz[a] += sz[b]; cc--;",
				"    }",
				"    ll time() {return history.size();}",
				"    ll rollback(ll until) ",
				"    {",
				"        ll cnt = 0; ",
				"        while (time() > until) ",
				"        {",
				"            history.back().fi = history.back().se; ",
				"            history.pop_back(); cnt++;",
				"        } ",
				"        cc += (cnt>>1); return (cnt>>1);",
				"    }",
				"} v;"						
			]
		}
		"cdq":
		{
			"prefix": ["cdq"],
			"body":
			[
				"struct point {ll x, y, z, i;};",
				"struct cmp ",
				"{",
				"    bool operator() (point a, point b) ",
				"    {",
				"        if (a.x != b.x) return a.x > b.x;",
				"        else if (a.y != b.y) return a.y < b.y;",
				"        else if (a.z != b.z) return a.z < b.z;",
				"        return a.i < b.i;",
				"    }",
				"};",
				"ll bit[mxn], n, k, f_ans = 0, x[mxn], y[mxn], z[mxn];",
				"bool ans[mxn];",
				"void upd(ll u, ll v) {while (u) {bit[u] += v; u -= (u&(-u));}}",
				"ll get(ll u) {ll sum = 0; while (u < mxn) {sum += bit[u]; u += (u&(-u));} return sum;}",
				"vector<point> v;",
				"void cdq(ll l, ll r)",
				"{",
				"    if (l == r) return;",
				"    ll m = (r+l)>>1; ll a = l, b = m+1;",
				"    cdq(l,m); cdq(m+1,r);",
				"    vector<point> tmp; vector<ll> revert;",
				"    while (a <= m && b <= r)",
				"    {",
				"        if (v[a].y > v[b].y) {upd(v[a].z,1); revert.pb(v[a].z); tmp.pb(v[a++]);}",
				"        else {ans[v[b].i] += get(v[b].z+1); tmp.pb(v[b++]);}",
				"    }",
				"    while (a <= m) tmp.pb(v[a++]);",
				"    while (b <= r) {ans[v[b].i] += get(v[b].z+1); tmp.pb(v[b++]);}",
				"    for (ll i = l; i <= r; i++) v[i] = tmp[i-l];",
				"    for (ll i : revert) upd(i,-1);",
				"}"					
			]
		}
		"bitmask_emu":
		{
			"prefix": ["mask_emu"],
			"body":
			[
				"    for (ll i = 0; i < (1LL<<n); i++)",
				"    {",
				"        for (ll j = i; j > 0; j = (j-1)&i)",
				"        {",
				"            dp[i] = max(dp[i],dp[i^j]+d[j]);",
				"        }",
				"    }"	
			]
		}
		"suffix_automaton":
		{
			"prefix": ["sam"],
			"body":
			[
				"struct suffix_automaton",
				"{",
				"    vector<map<char,ll>> nxt;",
				"    vector<ll> link, len, ter, state_occ, path;",
				"    vector<bool> vis;",
				"    ll last;",
				"    suffix_automaton() {}",
				"    suffix_automaton(string s, bool create_state_occ = 0, bool create_path = 0)",
				"    {",
				"        nxt.pb(map<char,ll>());",
				"        link.pb(-1); len.pb(0);",
				"        if (create_state_occ) state_occ.pb(1);",
				"        if (create_path) path.pb(1);",
				"        if (create_state_occ || create_path) vis.pb(0);",
				"        last = 0;",
				"        for (ll i = 0; i < s.size(); i++)",
				"        {",
				"            nxt.pb(map<char,ll>());",
				"            len.pb(i+1); link.pb(0);",
				"            if (create_state_occ) state_occ.pb(1);",
				"            if (create_path) path.pb(1);",
				"            if (create_state_occ || create_path) vis.pb(0);",
				"            ll r = nxt.size()-1, p = last;",
				"            while (p >= 0 && nxt[p].find(s[i]) == nxt[p].end())",
				"            {",
				"                nxt[p][s[i]] = r;",
				"                p = link[p];",
				"            }",
				"            if (p != -1)",
				"            {",
				"                ll q = nxt[p][s[i]];",
				"                if (len[p] + 1 == len[q]) link[r] = q;",
				"                else",
				"                {",
				"                    nxt.pb(nxt[q]); len.pb(len[p]+1); link.pb(link[q]);",
				"                    if (create_state_occ) state_occ.pb(0);",
				"                    if (create_path) path.pb(1);",
				"                    if (create_state_occ || create_path) vis.pb(0);",
				"                    ll qq = nxt.size()-1; link[q] = link[r] = qq;",
				"                    while (p >= 0 && nxt[p][s[i]] == q) ",
				"                    {",
				"                        nxt[p][s[i]] = qq;",
				"                        p = link[p];",
				"                    }",
				"                }",
				"            }",
				"            last = r;",
				"        } ",
				"    }",
				"    void build_ter()",
				"    {",
				"        ll p = last;",
				"        while (p > 0) {ter.pb(p); p = link[p];}",
				"        sort(ter.begin(), ter.end());",
				"    }",
				"    void build_state_occ()",
				"    {",
				"        vector<pair<ll,ll>> v;",
				"        for (ll i = 1; i < nxt.size(); i++) v.pb({len[i],i});",
				"        sort(v.begin(),v.end(),greater<pair<ll,ll>>());",
				"        for (pair<ll,ll> i : v) state_occ[link[i.se]] += state_occ[i.se];",
				"        state_occ[0] = 1; ",
				"    }",
				"    void full_build(ll u, bool create_state_occ = 0, bool create_path = 0)",
				"    {",
				"        vis[u] = 1;",
				"        for (pair<ll,ll> i : nxt[u])",
				"        {",
				"            if (!vis[i.se]) full_build(i.se, create_state_occ, create_path);",
				"            if (create_state_occ) state_occ[u] += state_occ[i.se];",
				"            if (create_path) path[u] += path[i.se];",
				"        }",
				"    }",
				"};"													
			]
		}
		"st_max":
		{
			"prefix": ["st_max"],
			"body":
			[
				"struct segment_tree",
				"{",
				"    ll st[mxn<<2];",
				"    void update(ll id, ll l, ll r, ll u, ll x)",
				"    {",
				"        if (r < u || u < l) return;",
				"        if (l == r)",
				"        {",
				"            st[id] = (st[id]+x);",
				"            return;",
				"        }",
				"        ll m = (r+l)>>1;",
				"        update(id<<1,l,m,u,x); update(id<<1|1,m+1,r,u,x);",
				"        st[id] = max(st[id<<1],st[id<<1|1]);",
				"    }",
				"    ll get(ll id, ll l, ll r, ll u, ll v)",
				"    {",
				"        if (r < u || v < l) return -1e18;",
				"        if (u <= l && r <= v) return st[id];",
				"        ll m = (r+l)>>1;",
				"        return max(get(id<<1,l,m,u,v),get(id<<1|1,m+1,r,u,v));",
				"    }",
				"};"				
			]
		}
		"phi_linear":
		{
			"prefix": ["phi_l"],
			"body":
			[
				"vector<ll> prime;",
				"bool is_com[mxn];",
				"ll phi[mxn];",
				"void sieve(ll n)",
				"{",
				"    phi[1] = 1;",
				"    for (ll i = 2; i <= n; i++)",
				"    {",
				"        if (!is_com[i])",
				"        {",
				"            prime.pb(i);",
				"            phi[i] = i-1;",
				"        }",
				"        for (ll j = 0; j < prime.size() && i*prime[j] <= n; j++)",
				"        {",
				"            is_com[i*prime[j]] = 1;",
				"            if (i % prime[j]) phi[i*prime[j]] = phi[i]*phi[prime[j]];",
				"            else {phi[i*prime[j]] = phi[i]*prime[j]; break;} ",
				"        }",
				"    }",
				"}"								
			]
		}
		"mob_linear":
		{
			"prefix": ["mob"],
			"body":
			[
				"vector<ll> prime;",
				"bool is_com[mxn];",
				"ll mob[mxn];",
				"void sieve(ll n)",
				"{",
				"    mob[1] = 1;",
				"    for (ll i = 2; i <= n; i++)",
				"    {",
				"        if (!is_com[i])",
				"        {",
				"            prime.pb(i);",
				"            mob[i] = -1;",
				"        }",
				"        for (ll j = 0; j < prime.size() && i*prime[j] <= n; j++)",
				"        {",
				"            is_com[i*prime[j]] = 1;",
				"            if (i % prime[j]) mob[i*prime[j]] = mob[i]*mob[prime[j]];",
				"            else {mob[i*prime[j]] = 0; break;} ",
				"        }",
				"    }",
				"}"											
			]
		}
		"linear":
		{
			"prefix": ["linear_sieve"],
			"body":
			[
				"vector<ll> prime;",
				"bool is_com[mxn];",
				"void sieve(ll n)",
				"{",
				"    for (ll i = 2; i <= n; i++)",
				"    {",
				"        if (!is_com[i]) prime.pb(i);",
				"        for (ll j = 0; j < prime.size() && i*prime[j] <= n; j++)",
				"        {",
				"            is_com[i*prime[j]] = 1;",
				"            if (i % prime[j] == 0) break;",
				"        }",
				"    }",
				"}"														
			]
		}
		"lagrange":
		{
			"prefix": ["lag"],
			"body":
			[
				"ll n, f[mxn], prf[mxn], suf[mxn], den[mxn];",
				"ll bpow(ll a, ll b)",
				"{",
				"    if (!b) return 1;",
				"    ll m = bpow(a,b/2);",
				"    if (b&1) return (((m*m)%mod)*a)%mod;",
				"    return (m*m)%mod;",
				"}",
				"ll inv(ll x) {return bpow(x,mod-2);}",
				"ll get_numerator(ll i) ",
				"{",
				"    if (i == 0) return suf[i+1];",
				"    else if (i == n) return prf[i-1];",
				"    return (prf[i-1]*suf[i+1])%mod;",
				"}",
				"ll get_denominator(ll i)",
				"{",
				"    if ((n-i)&1) return mod-((den[i]*den[n-i])%mod);",
				"    return (den[i]*den[n-i])%mod;",
				"}",
				"ll interpolation(ll x)",
				"{",
				"    // numerator precalculation",
				"    for (ll i = 0; i <= n; i++)",
				"    {",
				"        if (!i) prf[i] = x%mod;",
				"        else prf[i] = (prf[i-1]*(x-i))%mod;",
				"    }",
				"    for (ll i = n; i >= 0; i--)",
				"    {",
				"        if (i == n) suf[i] = (x-i)%mod;",
				"        else suf[i] = (suf[i+1]*(x-i))%mod;",
				"    }",
				"    // denominator precalculation",
				"    for (ll i = 0; i <= n; i++) ",
				"    {",
				"        if (!i) den[i] = 1;",
				"        else den[i] = (den[i-1]*i)%mod;",
				"    }",
				"    ll ans = 0;",
				"    for (ll i = 0; i <= n; i++)",
				"    {",
				"        ans += (f[i]*((get_numerator(i)*inv(get_denominator(i)))%mod))%mod;",
				"        ans %= mod; if (ans < 0) ans += mod;",
				"    }",
				"    return ans;",
				"}"																
			]
		}
		"st_sum":
		{
			"prefix": ["st_sum"],
			"body":
			[
				"struct segment_tree",
				"{",
				"    ll st[mxn<<2];",
				"    void update(ll id, ll l, ll r, ll u, ll x)",
				"    {",
				"        if (r < u || u < l) return;",
				"        if (l == r) {st[id] += x; return;}",
				"        ll m = (r+l)>>1;",
				"        update(id<<1,l,m,u,x); update(id<<1|1,m+1,r,u,x);",
				"        st[id] = st[id<<1]+st[id<<1|1];",
				"    }",
				"    ll get(ll id, ll l, ll r, ll u, ll v)",
				"    {",
				"        if (r < u || v < l) return 0;",
				"        if (u <= l && r <= v) return st[id];",
				"        ll m = (r+l)>>1;",
				"        return get(id<<1,l,m,u,v)+get(id<<1|1,m+1,r,u,v);",
				"    }",
				"};"				
			]
		}
		"sos":
		{
			"prefix": ["sos"],
			"body":
			[
				"    for (ll i = 0; i < 16; i++)",
				"    {",
				"        for (ll mask = 0; mask < (1LL<<16); mask++)",
				"        {",
				"            if (mask>>i&1) f[mask] += f[mask^(1LL<<i)];",
				"        }",
				"    }"								
			]
		}
		// 2sat
		"2sat":
		{
			"prefix": ["2sat"],
			"body":
			[
				"ll n, m, scc[mxn], low[mxn], num[mxn], cntscc = 0, tdfs = 0;",
				"bool del[mxn], type[mxn];   ",
				"vector<vector<ll>> g(mxn);",
				"stack<ll> s;",
				"void dfs(ll u)",
				"{",
				"    num[u] = low[u] = ++tdfs;",
				"    s.push(u);",
				"    for (auto i : g[u])",
				"    {",
				"        if (del[i]) continue;",
				"        if (!num[i])",
				"        {",
				"            dfs(i);",
				"            low[u] = min(low[u],low[i]);",
				"        }",
				"        else low[u] = min(low[u],num[i]);",
				"    }",
				"    if (num[u] == low[u])",
				"    {",
				"        cntscc++;",
				"        ll vi = s.top(), cnt = 1; s.pop();",
				"        while (vi != u)",
				"        {",
				"            cnt++; del[vi] = 1; scc[vi] = cntscc;",
				"            vi = s.top(); s.pop();",
				"        }",
				"        del[vi] = 1; scc[u] = cntscc; ",
				"    }",
				"}",
				"bool solve()",
				"{",
				"    for (ll i = 1; i <= 2*n; i++) {if (!num[i]) {dfs(i);}}",
				"    for (ll i = 1; i <= n; i++)",
				"    {",
				"        if (scc[i] == scc[i+n]) return 0;",
				"        else type[i] = (scc[i] < scc[i+n]); ",
				"    }",
				"    return 1;",
				"}"								
			]
		}
		// Segment Tree Iterative
		"st_ite":
		{
			"prefix": ["st_ite"],
			"body":
			[
				"void build()",
				"{",
				"    for (ll i = n; i < 2*n; i++) st[i] = val[arr[i-n+1]];",
				"    for (ll i = n-1;i >= 1; i--) st[i]=max(st[i<<1],st[i<<1|1]);",
				"}",
				"void update(ll i, ll x)",
				"{",
				"    for (st[i+=(n-1)]=x;i>1;i>>=1) st[i>>1]=max(st[i],st[i^1]);",
				"}",
				"ll get(ll l, ll r)",
				"{",
				"    ll s=-1e18;",
				"    for (l+=(n-1),r+=(n-1);l<=r;l>>=1,r>>=1)",
				"    {",
				"        if (l&1) s=max(s,st[l++]);",
				"        if (!(r&1)) s=max(s,st[r--]);",
				"    }",
				"    return s;",
				"}"				
			]
		}
		// Segment Tree Lazy
			// Sum
			"sum_st_lz":
			{
				"prefix": ["st_lz_sum"],
				"body":
				[
					"struct segment_tree",
					"{",
					"    ll st[mxn<<2], lz[mxn<<2];",
					"    void push(ll id, ll l, ll r)",
					"    {",
					"        if (!lz[id]) return;",
					"        ll m = (r+l)>>1;",
					"        st[id<<1] = (st[id<<1]+((lz[id]*(m-l+1))%mod))%mod;",
					"        st[id<<1|1] = (st[id<<1|1]+((lz[id]*(r-m))%mod))%mod;",
					"        lz[id<<1] = (lz[id<<1]+lz[id])%mod;",
					"        lz[id<<1|1] = (lz[id<<1|1]+lz[id])%mod;",
					"        lz[id] = 0;",
					"    }",
					"    void update(ll id, ll l, ll r, ll u, ll v, ll x)",
					"    {",
					"        if (r < u || v < l) return;",
					"        if (u <= l && r <= v)",
					"        {",
					"            st[id] = (st[id]+x)%mod; lz[id] = (lz[id]+x)%mod;",
					"            return;",
					"        }",
					"        ll m = (r+l)>>1; push(id,l,r);",
					"        update(id<<1,l,m,u,v,x); update(id<<1|1,m+1,r,u,v,x);",
					"        st[id] = (st[id<<1]+st[id<<1|1])%mod;",
					"    }",
					"    ll get(ll id, ll l, ll r, ll u, ll v)",
					"    {",
					"        if (r < u || v < l) return 0;",
					"        if (u <= l && r <= v) return st[id];",
					"        ll m = (r+l)>>1; push(id,l,r);",
					"        return (get(id<<1,l,m,u,v)+get(id<<1|1,m+1,r,u,v))%mod;",
					"    }",
					"};"					
				]
			}	
			// Max
			"mx_st_lz":
			{
				"prefix": ["st_lz_max"],
				"body":
				[
					"struct segment_tree",
					"{",
					"    ll st[mxn<<2], lz[mxn<<2];",
					"    void push(ll id, ll l, ll r)",
					"    {",
					"        if (!lz[id]) return;",
					"        ll m = (r+l)>>1;",
					"        st[id<<1] = (st[id<<1]+lz[id]);",
					"        st[id<<1|1] = (st[id<<1|1]+lz[id]);",
					"        lz[id<<1] = (lz[id<<1]+lz[id]);",
					"        lz[id<<1|1] = (lz[id<<1|1]+lz[id]);",
					"        lz[id] = 0;",
					"    }",
					"    void update(ll id, ll l, ll r, ll u, ll v, ll x)",
					"    {",
					"        if (r < u || v < l) return;",
					"        if (u <= l && r <= v)",
					"        {",
					"            st[id] = (st[id]+x); lz[id] = (lz[id]+x);",
					"            return;",
					"        }",
					"        ll m = (r+l)>>1; push(id,l,r);",
					"        update(id<<1,l,m,u,v,x); update(id<<1|1,m+1,r,u,v,x);",
					"        st[id] = max(st[id<<1],st[id<<1|1]);",
					"    }",
					"    ll get(ll id, ll l, ll r, ll u, ll v)",
					"    {",
					"        if (r < u || v < l) return -1e18;",
					"        if (u <= l && r <= v) return st[id];",
					"        ll m = (r+l)>>1; push(id,l,r);",
					"        return max(get(id<<1,l,m,u,v),get(id<<1|1,m+1,r,u,v));",
					"    }",
					"};"					
				]
			}
			// Min
			"st_mn_lz":
			{
				"prefix": ["st_lz_min"],
				"body":
				[
					"struct segment_tree",
					"{",
					"    ll st[mxn<<2], lz[mxn<<2];",
					"    void push(ll id, ll l, ll r)",
					"    {",
					"        if (!lz[id]) return;",
					"        ll m = (r+l)>>1;",
					"        st[id<<1] = (st[id<<1]+lz[id]);",
					"        st[id<<1|1] = (st[id<<1|1]+lz[id]);",
					"        lz[id<<1] = (lz[id<<1]+lz[id]);",
					"        lz[id<<1|1] = (lz[id<<1|1]+lz[id]);",
					"        lz[id] = 0;",
					"    }",
					"    void update(ll id, ll l, ll r, ll u, ll v, ll x)",
					"    {",
					"        if (r < u || v < l) return;",
					"        if (u <= l && r <= v)",
					"        {",
					"            st[id] = (st[id]+x); lz[id] = (lz[id]+x);",
					"            return;",
					"        }",
					"        ll m = (r+l)>>1; push(id,l,r);",
					"        update(id<<1,l,m,u,v,x); update(id<<1|1,m+1,r,u,v,x);",
					"        st[id] = min(st[id<<1],st[id<<1|1]);",
					"    }",
					"    ll get(ll id, ll l, ll r, ll u, ll v)",
					"    {",
					"        if (r < u || v < l) return 1e18;",
					"        if (u <= l && r <= v) return st[id];",
					"        ll m = (r+l)>>1; push(id,l,r);",
					"        return min(get(id<<1,l,m,u,v),get(id<<1|1,m+1,r,u,v));",
					"    }",
					"};"					
				]
			}
		// BIT
		"BIT":
		{
			"prefix": ["bit"],
			"body":
			[
				"ll bit[mxn];",
				"void upd(ll u, ll v) {while (u < mxn) {bit[u] += v; u += (u&(-u));}}",
				"ll get(ll u) {ll sum = 0; while (u) {sum += bit[u]; u -= (u&(-u));} return sum;}"				
			]
		}
		// Reverse BIT
		"RBIT":
		{
			"prefix": ["rbit"],
			"body":
			[
				"ll bit[mxn];",
				"void upd(ll u, ll v) {while (u) {bit[u] += v; u -= (u&(-u));}}",
				"ll get(ll u) {ll sum = 0; while (u < mxn) {sum += bit[u]; u += (u&(-u));} return sum;}"							
			]
		}
		// Trie
		"trie":
		{
			"prefix": ["trie"],
			"body":
			[
				"struct node",
				"{",
				"    ll cnt, child[26];",
				"    node() ",
				"    {",
				"        cnt = 0;",
				"        for (ll i = 0; i < 26; i++) child[i] = 0;",
				"    }",
				"};",
				"vector<node> trie;",
				"void add(string& x)",
				"{",
				"    ll u = 0;",
				"    for (ll i = 0; i < x.size(); i++)",
				"    {",
				"        if (!trie[u].child[x[i]-'a']) {trie.pb(node()); trie[u].child[x[i]-'a'] = trie.size()-1;}",
				"        u = trie[u].child[x[i]-'a'];",
				"    }",
				"    trie[u].cnt++;",
				"} "				
			]
		}
		// Binary Trie
		"bitrie":
		{
			"prefix": ["trie_2"],
			"body":
			[
				"struct node",
				"{",
				"    ll cnt, child[2];",
				"    node() {cnt = child[0] = child[1] = 0;}",
				"};",
				"vector<node> trie;",
				"void add(ll x)",
				"{",
				"    ll u = 0;",
				"    for (ll i = 31; i >= 0; i--)",
				"    {",
				"        bool d = (x>>i&1);",
				"        if (!trie[u].child[d]) {trie.pb(node()); trie[u].child[d] = trie.size()-1;}",
				"        trie[u].cnt++; u = trie[u].child[d];",
				"    }",
				"    trie[u].cnt++;",
				"}   ",
				"ll find(ll x, ll k)",
				"{",
				"    ll u = 0, ans = 0;",
				"    for (ll i = 31; i >= 0; i--)",
				"    {",
				"        bool d = (x>>i&1);",
				"        if (trie[u].child[!d])",
				"        {",
				"            if (trie[trie[u].child[!d]].cnt >= k)",
				"            {",
				"                ans += (1LL<<i)*(!d);",
				"                u = trie[u].child[!d];",
				"            }",
				"            else",
				"            {",
				"                ans += (1LL<<i)*d;",
				"                k -= trie[trie[u].child[!d]].cnt;",
				"                u = trie[u].child[d];",
				"            }",
				"        }",
				"        else",
				"        {",
				"            ans += (1LL<<i)*d;",
				"            u = trie[u].child[d];",
				"        }",
				"    }",
				"    return ans;",
				"}"
			]
		}
		// Aho-Corasick
		"Aho":
		{
			"prefix": ["aho"],
			"body":
			[
				"struct aho_corasick",
				"{",
				"    struct node ",
				"    {",
				"        ll suffix_link = -1, exit_link = -1, cnt = 0, nxt[26];",
				"        vector<ll> idx;",
				"        node() {fill(nxt,nxt+26,-1);}",
				"    };",
				"    vector<node> trie = {node()};",
				"    void add(const string& s, ll id)",
				"    {",
				"        ll u = 0;",
				"        for (ll i = 0; i < s.size(); i++)",
				"        {",
				"            if (trie[u].nxt[s[i]-'a'] == -1)",
				"            {",
				"                trie[u].nxt[s[i]-'a'] = trie.size();",
				"                trie.pb(node());",
				"            }",
				"            u = trie[u].nxt[s[i]-'a'];",
				"        }",
				"        trie[u].cnt++; trie[u].idx.pb(id); ",
				"    }",
				"    void build()",
				"    {",
				"        queue<ll> q; q.push(0);",
				"        while (!q.empty())",
				"        {",
				"            ll u = q.front(), suffix_link = trie[q.front()].suffix_link; q.pop();",
				"            if (u)",
				"            {",
				"                if (trie[suffix_link].cnt) trie[u].exit_link = suffix_link;",
				"                else trie[u].exit_link = trie[suffix_link].exit_link;",
				"            }",
				"            for (ll i = 0; i < 26; i++)",
				"            {",
				"                ll &nxt = trie[u].nxt[i], nxt_suffix = 0;",
				"                if (u) nxt_suffix = trie[suffix_link].nxt[i];",
				"                if (nxt == -1) nxt = nxt_suffix;",
				"                else",
				"                {",
				"                    trie[nxt].suffix_link = nxt_suffix;",
				"                    q.push(nxt);",
				"                } ",
				"            }",
				"        }",
				"    }",
				"    vector<ll> get_id(ll u)",
				"    {",
				"        vector<ll> res;",
				"        if (!trie[u].idx.size()) u = trie[u].exit_link;",
				"        while (u != -1) ",
				"        {",
				"            for (ll i : trie[u].idx) res.pb(i);",
				"            u = trie[u].exit_link;",
				"        }",
				"        return res;",
				"    }",
				"    void get(const string& t)",
				"    {",
				"        for (ll i = 0, u = 0; i < t.size(); i++)",
				"        {",
				"            u = trie[u].nxt[t[i]-'a'];",
				"            for (ll j : get_id(u)) cntx[j]++;",
				"        }",
				"    }",
				"    vector<vector<ll>> to_tree()",
				"    {",
				"        vector<vector<ll>> tree(trie.size());",
				"        for (ll i = 1; i < trie.size(); i++) tree[trie[i].suffix_link].pb(i);",
				"        return tree;",
				"    }",
				"};"				
			]
		}
		// Square-Root Decomposition
			// basic
			"sqrt":
			{
				"prefix": ["sqrt_basic"],
				"body":
				[
					"#include <bits/stdc++.h>",
					"using namespace std;",
					"typedef long long int ll;",
					"#define pb push_back",
					"#define fi first",
					"#define se second",
					"const ll mod = 1e9+7, mxn = 3e4+7, block_size = 320;",
					"ll a[mxn], n;",
					"ll v[block_size+7][10007];",
					"ll get(ll p, ll i)",
					"{",
					"    ll idx = p, ans = 0;",
					"    while (idx <= 1e4)",
					"    {",
					"        ans += v[i][idx];",
					"        idx += (idx&(-idx));",
					"    }",
					"    return ans;",
					"}",
					"void update(ll u, ll vx, ll i)",
					"{",
					"    ll idx = u;",
					"    while (idx > 0)",
					"    {",
					"        v[i][idx] += vx;",
					"        idx -= (idx&(-idx));",
					"    }",
					"}",
					"ll query(ll l, ll r, ll k)",
					"{",
					"    ll ans = 0;",
					"    while (l<=r && l%block_size != 0) ans += a[l++]>k;",
					"    while (l<=r && r%block_size != block_size-1) ans += a[r--]>k;",
					"    if (l < r)",
					"    {",
					"        ll bl = l/block_size, br = r/block_size;",
					"        for (ll i = bl; i <= br; i++) ans += get(k+1,i);",
					"    }",
					"    return ans;",
					"}",
					"void updatesq(ll u, ll v)",
					"{",
					"    ll block = u / block_size;",
					"    update(a[u],-1,block);",
					"    a[u] = v;",
					"    update(a[u],1,block);",
					"}",
					"signed main()",
					"{",
					"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
					"    cin >> n;",
					"    for (ll i = 1; i <= n; i++) ",
					"    {",
					"        cin >> a[i];",
					"        update(a[i],1,i/block_size);",
					"    }",
					"    ll q; cin >> q;",
					"    while (q--)",
					"    {",
					"        bool type; cin >> type;",
					"        if (!type)",
					"        {",
					"            ll i, v; cin >> i >> v;",
					"            updatesq(i,v);",
					"        }",
					"        else",
					"        {",
					"            ll i, j, k; cin >> i >> j >> k;",
					"            cout << query(i,j,k) << '\n';",
					"        }",
					"    }",
					"}"					
				]
			}
			// mo
			"mo":
			{
				"prefix": ["sqrt_mo"],
				"body":
				[
					"#include <bits/stdc++.h>",
					"using namespace std;",
					"typedef int ll;",
					"#define pb push_back",
					"#define fi first",
					"#define se second",
					"const ll mod = 1e9+7, mxn = 1e5+7, block_size = 450;",
					"ll n, q, a[mxn], bit[mxn], mo_l = 0, mo_r = 0, cnt = 0;",
					"long long anx[mxn], ans = 0;",
					"vector<ll> v;",
					"struct query {ll l, r, idx;};",
					"struct cmp",
					"{",
					"    bool operator() (query ax, query b)",
					"    {",
					"        if ((ax.l/block_size) != (b.l/block_size)) return (ax.l/block_size) < (b.l/block_size);",
					"        return ax.r < b.r;",
					"    } ",
					"};",
					"vector<query> qx;",
					"ll get(ll x) {ll ax = 0; while (x) {ax += bit[x]; x -= (x&(-x));} return ax;}",
					"void upd(ll x, ll vx) {while (x < mxn) {bit[x] += vx; x += (x&(-x));}}",
					"void add1(ll x)",
					"{   ",
					"    if (!x) return;",
					"    ans += cnt-get(a[x]);",
					"    upd(a[x],1); cnt++;",
					"}   ",
					"void rmv1(ll x)",
					"{",
					"    if (!x) return;",
					"    ans -= cnt-get(a[x]);",
					"    upd(a[x],-1); cnt--;",
					"}",
					"void add2(ll x)",
					"{",
					"    if (!x) return;",
					"    ans += get(a[x]-1);",
					"    upd(a[x],1); cnt++; ",
					"}",
					"void rmv2(ll x)",
					"{",
					"    if (!x) return;",
					"    ans -= get(a[x]-1);",
					"    upd(a[x],-1); cnt--;",
					"}",
					"signed main()",
					"{",
					"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
					"    cin >> n >> q; v.pb((ll)(-1e18)); v.pb((ll)(-1e18));",
					"    for (ll i = 1; i <= n; i++) {cin >> a[i]; v.pb(a[i]);}",
					"    sort(v.begin(),v.end());",
					"    for (ll i = 1; i <= n; i++) a[i] = lower_bound(v.begin(),v.end(),a[i])-v.begin();",
					"    for (ll i = 1; i <= q; i++)",
					"    {",
					"        ll l, r; cin >> l >> r;",
					"        qx.pb({l,r,i});",
					"    }",
					"    sort(qx.begin(),qx.end(),cmp());",
					"    for (query i : qx)",
					"    {",
					"        ll l = i.l, r = i.r;",
					"        while (mo_l < l) {rmv2(mo_l++);}",
					"        while (mo_l > l) {add2(--mo_l);}",
					"        while (mo_r < r) {add1(++mo_r);}",
					"        while (mo_r > r) {rmv1(mo_r--);}",
					"        anx[i.idx] = ans;",
					"    }",
					"}"					
				]
			}
			// query

			// batch

			// heavy_light
			"sqrthl":
			{
				"prefix": ["sqrt_h_l"],
				"body":
				[
					"#include <bits/stdc++.h>",
					"using namespace std;",
					"typedef long long int ll;",
					"#define pb push_back",
					"#define fi first",
					"#define se second",
					"const ll mod = 1e9+7, mxn = 1e5+7, block_size = 320;",
					"ll a[mxn], add[mxn], n, q;",
					"bool is_heavy[mxn];",
					"vector<vector<ll>> g(mxn), heavy(mxn);",
					"signed main()",
					"{",
					"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
					"    cin >> n >> q;",
					"    for (ll i = 1; i < n; i++)",
					"    {",
					"        ll a, b; cin >> a >> b;",
					"        g[a].pb(b); g[b].pb(a);",
					"    }",
					"    for (ll i = 1; i <= n; i++)",
					"    {",
					"        if (g[i].size() > block_size) is_heavy[i] = 1;",
					"    }",
					"    for (ll i = 1; i <= n; i++)",
					"    {",
					"        for (ll j : g[i])",
					"        {",
					"            if (is_heavy[j]) heavy[i].pb(j);",
					"        }",
					"    }",
					"    while (q--)",
					"    {",
					"        ll type; cin >> type;",
					"        if (type == 1)",
					"        {",
					"            ll u, d; cin >> u >> d;",
					"            if (is_heavy[u]) add[u] += d;",
					"            else",
					"            {",
					"                for (ll i : g[u]) a[i] += d;",
					"            }",
					"        }",
					"        else",
					"        {",
					"            ll x; cin >> x;",
					"            ll ans = a[x];",
					"            for (ll i : heavy[x]) ans += add[i];",
					"        }",
					"    }",
					"}"					
				]
			}
		// Sparse Table
		"RMQ":
		{
			"prefix": ["rmq"],
			"body":
			[
				"ll up[mxn][20], n;",
				"void precalc() ",
				"{",
				"    for (ll i = 1; i <= n; i++) cin >> up[i][0];",
				"    for (ll j = 1; j < 20; j++)",
				"    {",
				"        for (int i = 1; i+(1<<j)-1 <= n; i++)",
				"        {",
				"            up[i][j] = max(up[i][j-1],up[i+(1<<(j-1))][j-1]);",
				"        }",
				"    }",
				"}",
				"int rmq(ll l, ll r) ",
				"{",
				"    ll k = __lg(r - l + 1);",
				"    return max(up[l][k], up[r-(1<<k)+1][k]);",
				"}"				
			]
		}
		// Sparse Table 2D
		"sparse2":
		{
			"prefix": ["sparse2"],
			"body":
			[
				"int st[11][mxn][11][mxn];",
				"void precalc()",
				"{",
				"    for (int k = 0; k <= 10; ++k)",
				"    {",
				"        for (int i = 1; i + (1 << k) - 1 <= n; ++i)",
				"        {",
				"            for (int l = 0; l <= 10; ++l)",
				"            {",
				"                for (int j = 1; j + (1 << l) - 1 <= m; ++j)",
				"                {",
				"                    if (k == 0)",
				"                    {",
				"                        if (l == 0)",
				"                        {",
				"                            st[0][i][0][j] = ax[i][j];",
				"                        }",
				"                        else",
				"                        {",
				"                            st[0][i][l][j] = min(st[0][i][l - 1][j], st[0][i][l - 1][j + (1 << (l - 1))]);",
				"                        }",
				"                    }",
				"                    else",
				"                    { ",
				"                        st[k][i][l][j] = min(st[k - 1][i][l][j], st[k - 1][i + (1 << (k - 1))][l][j]);",
				"                    }",
				"                }",
				"            }",
				"        }",
				"    }",
				"}",
				"int rmq(int x, int y, int a, int b) ",
				"{",
				"    int k = __lg(a - x + 1);",
				"    int l = __lg(b - y + 1);",
				"    return min({st[k][x][l][y],",
				"                st[k][x][l][b-(1<<l)+1],",
				"                st[k][a-(1<<k)+1][l][y],",
				"                st[k][a-(1<<k)+1][l][b-(1<<l)+1]});",
				"}"				
			]
		}
		// Monotonic Queue Left_Max

		// Monotonic Queue Right_Max

		// DSU
		"DSU":
		{
			"prefix": ["dsu"],
			"body":
			[
				"ll pr[mxn], n;",
				"ll fs(ll u)",
				"{",
				"    if (u == pr[u]) return u;",
				"    return pr[u] = fs(pr[u]);",
				"}",
				"bool us(ll u, ll v)",
				"{",
				"    u = fs(u); v = fs(v);",
				"    if (u == v) return 0;",
				"    pr[u] = v; return 1;",
				"}",
				"void setup() {for (ll i = 1; i <= n; i++) {pr[i] = i;}}"				
			]
		}
		// Centroid Tree
		"CenTree":
		{
			"prefix": ["centree"],
			"body":
			[
				"struct centroid_tree",
				"{",
				"    ll n;",
				"    vector<vector<ll>> g, up;",
				"    vector<ll> pr, opt, sz, h;",
				"    vector<bool> del;",
				"    centroid_tree(ll nx)",
				"    {",
				"        n = nx; vector<ll> v, vv(20);",
				"        for (ll i = 0; i <= n; i++)",
				"        {",
				"            g.pb(v); up.pb(vv);",
				"            pr.pb(0); opt.pb(mod); sz.pb(0); del.pb(0); h.pb(0);",
				"        }",
				"    }",
				"    void get_tree()",
				"    {",
				"        for (ll i = 1; i < n; i++)",
				"        {",
				"            ll a, b; cin >> a >> b;",
				"            g[a].pb(b); g[b].pb(a);",
				"        }",
				"    }",
				"    void dfs(ll u, ll v)",
				"    {",
				"        for (ll i : g[u])",
				"        {",
				"            if (i != v)",
				"            {",
				"                h[i] = h[u]+1; up[i][0] = u;",
				"                dfs(i,u);",
				"            }",
				"        }",
				"    }",
				"    void build_lca() {for (ll i = 1; i < 20; i++) {for (ll j = 1; j <= n; j++) {up[j][i] = up[up[j][i-1]][i-1];}}}",
				"    ll get_lca(ll u, ll v) ",
				"    {",
				"        if (h[u] != h[v])",
				"        {",
				"            if (h[u] < h[v]) swap(u,v);",
				"            ll k = h[u]-h[v];",
				"            for (ll i = 0; i < 20; i++) {if (k>>i&1) {u = up[u][i];}}",
				"        }",
				"        if (u == v) return u;",
				"        for (ll i = 19; i >= 0; i--)",
				"        {",
				"            if (up[u][i] != up[v][i])",
				"            {",
				"                u = up[u][i];",
				"                v = up[v][i];",
				"            }",
				"        }",
				"        return up[u][0];",
				"    }",
				"    ll get_dist(ll u, ll v) {return h[u]+h[v]-2*h[get_lca(u,v)];}",
				"    void dfs_sz(ll u, ll v)",
				"    {",
				"        sz[u] = 1;",
				"        for (ll i : g[u])",
				"        {",
				"            if (i != v && !del[i]) ",
				"            {",
				"                dfs_sz(i,u);",
				"                sz[u] += sz[i];",
				"            }",
				"        }",
				"    }",
				"    ll dfs_centroid(ll u, ll v, ll szx)",
				"    {",
				"        for (ll i : g[u]) {if (i != v && sz[i] > szx/2 && !del[i]) {return dfs_centroid(i,u,szx);}}",
				"        return u;",
				"    }",
				"    ll build(ll u)",
				"    {",
				"        dfs_sz(u,u);",
				"        ll root = dfs_centroid(u,u,sz[u]);",
				"        del[root] = 1;",
				"        for (ll i : g[root])",
				"        {",
				"            if (!del[i])",
				"            {",
				"                ll nxt = build(i);",
				"                pr[nxt] = root; ",
				"            }",
				"        }",
				"        return root;",
				"    }",
				"    void update(ll u)",
				"    {",
				"        ll old_u = u;",
				"        while (u)",
				"        {",
				"            opt[u] = min(opt[u],get_dist(u,old_u));",
				"            u = pr[u];",
				"        }",
				"    }",
				"    ll get(ll u)",
				"    {",
				"        ll old_u = u, ans = 1e18;",
				"        while (u) ",
				"        {",
				"            ans = min(ans,opt[u]+get_dist(u,old_u));",
				"            u = pr[u];",
				"        }",
				"        return ans;",
				"    }",
				"};"				
			]
		}
		// Reachability Tree

	// Graph
		// DFS / BFS
		"bfs":
		{
			"prefix": ["bfs"],
			"body":
			[
				"bool vis[mxn];",
				"vector<vector<ll>> g(mxn);",
				"void bfs(ll u)",
				"{",
				"    queue<ll> q; q.push(u); vis[u] = 1;",
				"    while (!q.empty())",
				"    {",
				"        ll u = q.front(); q.pop();",
				"        for (ll i : g[u])",
				"        {",
				"            if (!vis[i]) ",
				"            {",
				"                q.push(i); vis[i] = 1;",
				"            }",
				"        }",
				"    }",
				"}"				
			]
		}
		// Dijkstra
		"dijkstra":
		{
			"prefix": ["dijkstra"],
			"body":
			[
				"ll n, m, d[2][mxn];",
				"bool vis[2][mxn];",
				"vector<vector<pair<ll,ll>>> g(mxn);",
				"struct node {ll u, dist;};",
				"struct cmp {bool operator() (node a, node b) {return a.dist > b.dist;}};",
				"void dijkstra(ll s, ll id)",
				"{",
				"    for (ll i = 1; i <= n; i++) d[id][i] = 1e18;",
				"    d[id][s] = 0;",
				"    priority_queue<node,vector<node>,cmp> pq;",
				"    pq.push({s,0});",
				"    while (!pq.empty())",
				"    {",
				"        ll u = pq.top().u; pq.pop();",
				"        if (vis[id][u]) continue;",
				"        vis[id][u] = 1;",
				"        for (pair<ll,ll> i : g[u])",
				"        {",
				"            if (d[id][i.fi] > d[id][u]+i.se)",
				"            {",
				"                d[id][i.fi] = d[id][u]+i.se;",
				"                pq.push({i.fi,d[id][i.fi]});",
				"            }",
				"        }",
				"    }   ",
				"}"				
			]
		}
		// Bellman-Ford
		
		// Bellman-Ford Negative Cycle
		"floyd_neg":
		{
			"prefix": ["floyd_neg"],
			"body":
			[
				"        for (ll i = 0; i < n; i++)",
				"        {",
				"            for (ll j = 0; j < n; j++) d[i][j] = 1e9;",
				"            d[i][i] = 0;",
				"        }",
				"        for (ll i = 0; i < m; i++)",
				"        {",
				"            ll a,b,c; cin >> a >> b >> c;",
				"            d[a][b] = min(d[a][b],c);",
				"        }",
				"        for (ll k = 0; k < n; k++)",
				"        {",
				"            for (ll i = 0; i < n; i++)",
				"            {",
				"                for (ll j = 0; j < n; j++) ",
				"                {",
				"                    if (d[i][j] > d[i][k]+d[k][j] && d[i][k] != 1e9 && d[k][j] != 1e9) d[i][j] = d[i][k]+d[k][j];",
				"                    if (d[i][j] < -1e9) d[i][j] = -1e9;",
				"                }",
				"            }",
				"        }",
				"        for (ll k = 0; k < n; k++)",
				"        {",
				"            for (ll i = 0; i < n; i++)",
				"            {",
				"                for (ll j = 0; j < n; j++)",
				"                {",
				"                    if (d[i][j] > d[i][k]+d[k][j]  && d[i][k] != 1e9 && d[k][j] != 1e9) d[i][j] = -1e9;",
				"                }",
				"            }",
				"        }"				
			]
		}
		// Floyd
		"floyd":
		{
			"prefix": ["floyd"],
			"body":
			[
				"        ll n, m; cin >> n >> m;",
				"        for (ll i = 1; i <= n; i++)",
				"        {",
				"            for (ll j = 1; j <= n; j++) dp[i][j] = 1e15;",
				"        }",
				"        vector<edge> v;",
				"        for (ll i = 0; i < m; i++)",
				"        {",
				"            ll a,b,c; cin >> a >> b >> c;",
				"            v.pb({a,b,c}); dp[a][b] = c; //dp[b][a] = c;",
				"        }",
				"        for (ll k = 1; k <= n; k++)",
				"        {",
				"            for (ll i = 1; i <= n; i++)",
				"            {",
				"                for (ll j = 1; j <= n; j++) dp[i][j] = min(dp[i][k]+dp[k][j],dp[i][j]);",
				"            }",
				"        }"				
			]
		}
		// fft
		"fft":
		{
			"prefix": ["fft"],
			"body":
			[
				"using cd = complex<ld>;",
				"const ld pi = acos(-1);",
				"void fft(vector<cd>& a, bool invert)",
				"{",
				"    ll n = a.size();",
				"    if (n == 1) return;",
				"    vector<cd> a0(n/2), a1(n/2);",
				"    for (ll i = 0; i*2 < n; i++) {a0[i] = a[2*i]; a1[i] = a[2*i+1];}",
				"    fft(a0,invert); fft(a1,invert);",
				"    ld ang = 2*pi/n*(invert?-1:1);",
				"    cd w(1), wn(cos(ang),sin(ang));",
				"    for (ll i = 0; i*2 < n; i++)",
				"    {",
				"        a[i] = a0[i]+w*a1[i];",
				"        a[i+n/2] = a0[i]-w*a1[i];",
				"        if (invert) {a[i] /= 2; a[i+n/2] /= 2;}",
				"        w *= wn;",
				"    }",
				"}",
				"vector<ll> multiply(vector<ll> const& a, vector<ll> const& b)",
				"{",
				"    vector<cd> fa(a.begin(),a.end()), fb(b.begin(),b.end());",
				"    ll n = 1; while (n < a.size()+b.size()) {n <<= 1;}",
				"    fa.resize(n); fb.resize(n); fft(fa,0); fft(fb,0);",
				"    for (ll i = 0; i < n; i++) fa[i] *= fb[i];",
				"    fft(fa,1); vector<ll> result(n);",
				"    for (ll i = 0; i < n; i++) result[i] = round(fa[i].real());",
				"    return result;",
				"}"
			]
		}
		// ntt
		"ntt":
		{
			"prefix": ["ntt"],
			"body":
			[
				"const ll mod_ntt = 998244353, root = 15311432, root_1 = 469870224, root_pw = 1LL<<23;",
				"ll bpow(ll a, ll b)",
				"{",
				"    if (!b) return 1;",
				"    ll m = bpow(a,b/2);",
				"    if (b&1) return (((m*m)%mod_ntt)*a)%mod_ntt;",
				"    return (m*m)%mod_ntt;",
				"}",
				"void ntt(vector<ll>& a, bool invert)",
				"{",
				"    ll n = a.size();",
				"    for (ll i = 1, j = 0; i < n; i++)",
				"    {",
				"        ll bit = (n>>1);",
				"        for (; j&bit; bit>>=1) {j ^= bit;} j ^= bit;",
				"        if (i < j) swap(a[i],a[j]);",
				"    }",
				"    for (ll l = 2; l <= n; l <<= 1)",
				"    {",
				"        ll wl = invert ? root_1 : root;",
				"        for (ll i = l; i < root_pw; i <<= 1) wl = ((wl*wl)%mod_ntt);",
				"        for (ll i = 0; i < n; i += l)",
				"        {",
				"            ll w = 1;",
				"            for (ll j = 0; j < l/2; j++)",
				"            {",
				"                ll u = a[i+j], v = ((a[i+j+l/2]*w)%mod_ntt);",
				"                a[i+j] = ((u+v) < mod_ntt) ? (u+v) : (u+v-mod_ntt);",
				"                a[i+j+l/2] = ((u-v) >= 0) ? (u-v) : (u-v+mod_ntt);",
				"                w = (w*wl)%mod_ntt;",
				"            }",
				"        }",
				"    }",
				"    if (invert)",
				"    {",
				"        ll n_1 = bpow(n,mod_ntt-2);",
				"        for (ll& i : a) i = (i*n_1)%mod_ntt;",
				"    }",
				"}",
				"vector<ll> multiply(vector<ll> const& a, vector<ll> const& b)",
				"{",
				"    vector<ll> fa(a.begin(),a.end()), fb(b.begin(),b.end());",
				"    ll n = 1; while (n < a.size()+b.size()) {n <<= 1;}",
				"    fa.resize(n); fb.resize(n); ntt(fa,0); ntt(fb,0);",
				"    for (ll i = 0; i < n; i++) fa[i] = (fa[i]*fb[i])%mod_ntt;",
				"    ntt(fa,1); return fa;",
				"}"										
			]
		}
		// Hierholzer
		"hierholzer":
		{
			"prefix": ["hierholzer"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long int ll;",
				"#define pb push_back",
				"#define pf push_front",
				"#define fi first",
				"#define se second",
				"const ll mod = 1e9+7, mxn = 2e5+7;",
				"vector<vector<pair<ll,ll>>> g(mxn);",
				"bool used[mxn];",
				"ll n, m, st;",
				"list<ll> euler_path(ll u)",
				"{",
				"    list<ll> ans;",
				"    ans.pb(u);",
				"    while (!g[u].empty())",
				"    {",
				"        ll nxt = g[u].back().fi, id = g[u].back().se;",
				"        g[u].pop_back();",
				"        if (used[id]) continue;",
				"        used[id] = 1; u = nxt;",
				"        ans.pb(u);",
				"    }",
				"    for (list<ll>::iterator it = ++ans.begin(); it != ans.end(); it++) ",
				"    {",
				"        list<ll> t = euler_path(*it);",
				"        t.pop_back(); ans.splice(it,t);",
				"    }",
				"    return ans; ",
				"}",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> n >> m;",
				"    for (ll i = 1; i <= m; i++)",
				"    {",
				"        ll a, b; cin >> a >> b;",
				"        g[a].pb({b,i}); // g[b].pb({a,i});",
				"        in[b]++; out[a]++;",
				"    }",
				"    int euler_graph = 2, st_path, st_;",
				"    for (ll i = 1; i <= n; i++) ",
				"    {",
				"        if (out[i] != in[i]) euler_graph = 1;",
				"        if (abs(out[i]-in[i]) > 1) {euler_graph = 0; break;}",
				"    }",
				"    list<ll> ans = euler_path(3);",
				"    for (ll i : ans) cout << i << ' ';",
				"}"					
			]
		}
		// SCC Merging DAG
		
		// Topo-sort DFS

		// Topo-sort Kahn
		"kahn":
		{
			"prefix": ["kahn"],
			"body":
			[
				"    for (ll i = 1; i <= n; i++)",
				"    {",
				"        if (!deg[i]) q.push(i);",
				"    }",
				"    while (!q.empty())",
				"    {",
				"        v.pb(q.front()); pos[q.front()] = v.size();",
				"        for (ll i : g[q.front()])",
				"        {",
				"            deg[i]--;",
				"            if (!deg[i]) q.push(i);",
				"        }",
				"        q.pop();",
				"    }"				
			]
		}
		// MST

		// Lubenica
		"lubenica":
		{
			"prefix": ["lubenica"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long ll;",
				"#define pb push_back",
				"#define pf push_front",
				"const ll mod = 1e9+7, mxn = 1e5+7;",
				"ll n, up[20][mxn][3], q, h[mxn];",
				"vector<vector<pair<ll,ll>>> v;",
				"void dfs(ll u)",
				"{",
				"    for (auto i : v[u])",
				"    {",
				"        ll vx = i.first, dx = i.second;",
				"        if (vx == up[0][u][0]) continue;",
				"        h[vx] = h[u]+1; up[0][vx][0] = u; up[0][vx][1] = dx; up[0][vx][2] = dx;",
				"        for (ll i = 1; i <= 17; i++) ",
				"        {",
				"            up[i][vx][1] = max(up[i-1][vx][1],up[i-1][up[i-1][vx][0]][1]);",
				"            up[i][vx][2] = min(up[i-1][vx][2],up[i-1][up[i-1][vx][0]][2]);",
				"            up[i][vx][0] = up[i-1][up[i-1][vx][0]][0];",
				"        }",
				"        dfs(vx);",
				"    }",
				"}",
				"pair<ll,ll> lca(ll u, ll v)",
				"{",
				"    ll mxd = 0, mnd = INT_MAX;",
				"    if (h[u] != h[v])",
				"    {",
				"        if (h[u] < h[v]) swap(u,v);",
				"        ll k = h[u]-h[v];",
				"        for (ll i = 17; i >= 0; i--)",
				"        {",
				"            if (k >> i & 1) ",
				"            {",
				"                mxd = max(mxd,up[i][u][1]); mnd = min(mnd,up[i][u][2]);",
				"                u = up[i][u][0];",
				"            }",
				"        }",
				"    }   ",
				"    if (u == v) return {mxd,mnd};",
				"    for (ll i = 17; i >= 0; i--)",
				"    {",
				"        if (up[i][u][0] != up[i][v][0])",
				"        {",
				"            mxd = max(mxd,max(up[i][u][1],up[i][v][1])); mnd = min(mnd,min(up[i][u][2],up[i][v][2]));",
				"            u = up[i][u][0]; v = up[i][v][0];",
				"        }",
				"    }",
				"    return {max(mxd,max(up[0][u][1],up[0][v][1])),min(mnd,min(up[0][u][2],up[0][v][2]))};",
				"}",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> n; vector<pair<ll,ll>> x;",
				"    for (ll i = 0; i <= n; i++) v.pb(x);",
				"    for (ll i = 1; i < n; i++)",
				"    {",
				"        ll a,b,c; cin >> a >> b >> c;",
				"        v[a].pb({b,c}); v[b].pb({a,c});",
				"    }",
				"    dfs(1); cin >> q;",
				"    for (ll i = 0; i < q; i++)",
				"    {",
				"        ll a,b; cin >> a >> b;",
				"        pair<ll,ll> ans = lca(a,b);",
				"    }",
				"}"				
			]
		}
		// 0-1 BFS
		"01bfs":
		{
			"prefix": ["01bfs"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef int ll;",
				"#define pb push_back",
				"#define pf push_front",
				"#define fi first",
				"#define se second",
				"const ll mod = 1e9+7, mxn = 2e3+7;",
				"ll n, dp[mxn][mxn][4];",
				"bool a[mxn][mxn];",
				"struct edge {ll i, j, dir;};",
				"deque<edge> d;",
				"ll dx[4] = {-1,0,1,0}, ",
				"   dy[4] = {0,-1,0,1};",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> n;",
				"    for (ll i = 1; i <= n; i++)",
				"    {",
				"        string s; cin >> s;",
				"        for (ll j = 1; j <= n; j++)",
				"        {",
				"            if (s[j-1] == '.') a[i][j] = 1;",
				"            dp[i][j][0] = mod; dp[i][j][1] = mod;",
				"            dp[i][j][2] = mod; dp[i][j][3] = mod;",
				"        }",
				"    }",
				"    d.pf({1,1,2}); dp[1][1][2] = 0;",
				"    while (!d.empty())",
				"    {",
				"        ll i = d.front().i, j = d.front().j, dir = d.front().dir; d.pop_front();",
				"        for (ll k = 0; k < 4; k++)",
				"        {",
				"            if ((((k&1) != (dir&1)) || k == dir) && a[i+dx[k]][j+dy[k]])",
				"            {",
				"                if (k == dir)",
				"                {",
				"                    if (dp[i][j][k] < dp[i+dx[k]][j+dy[k]][k])",
				"                    {",
				"                        dp[i+dx[k]][j+dy[k]][k] = dp[i][j][k];",
				"                        d.pf({i+dx[k],j+dy[k],k});",
				"                    }",
				"                }",
				"                else",
				"                {",
				"                    if (dp[i][j][dir]+1 < dp[i][j][k])",
				"                    {",
				"                        dp[i][j][k] = dp[i][j][dir]+1;",
				"                        d.pb({i,j,k});",
				"                    }",
				"                }",
				"            }",
				"        }",
				"    }",
				"    if (min({dp[n][n][0], dp[n][n][1], dp[n][n][2], dp[n][n][3]}) == mod) cout << -1 << '\n';",
				"    else cout << min({dp[n][n][0], dp[n][n][1], dp[n][n][2], dp[n][n][3]});",
				"}"				
			]
		}
	// Tree
		// Sack
		"Sack":
		{
			"prefix": ["sack"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long int ll;",
				"#define pb push_back",
				"#define pf push_front",
				"#define fi first",
				"#define se second",
				"const ll mod = 1e9+7, mxn = 1e5+7;",
				"ll n, q, sz[mxn], big[mxn], ans[mxn], h[mxn], tin[mxn], tout[mxn], tmp_ans[mxn], cnt[mxn], euler[mxn], tdfs = 0, up[mxn][20];",
				"vector<ll> root, v;",
				"vector<vector<ll>> g(mxn);",
				"vector<vector<pair<ll,ll>>> qx(mxn);",
				"void dfs(ll u) ",
				"{",
				"    tin[u] = ++tdfs; euler[tdfs] = u; sz[u] = 1; big[u] = -1; v.pb(u);",
				"    for (ll i : g[u]) ",
				"    {",
				"        h[i] = h[u]+1; dfs(i); sz[u] += sz[i]; up[i][0] = u;",
				"        if (big[u] == -1 || sz[i] > sz[big[u]]) big[u] = i;",
				"    } ",
				"    tout[u] = tdfs;",
				"}",
				"void build() {for (ll i = 1; i < 20; i++) {for (ll j : v) {up[j][i] = up[up[j][i-1]][i-1];}}}",
				"ll get(ll u, ll d) {for (ll i = 0; i < 20; i++) {if (d>>i&1) {u = up[u][i];}} return u;}",
				"void solve(ll u, bool clear)",
				"{",
				"    for (ll i : g[u]) {if (i != big[u]) {solve(i,1);}}",
				"    if (big[u] != -1) solve(big[u],0);",
				"    for (ll i : g[u]) {if (i != big[u]) {for (ll j = tin[i]; j <= tout[i]; j++) cnt[h[euler[j]]]++;}}",
				"    cnt[h[u]]++;",
				"    for (pair<ll,ll> i : qx[u]) ans[i.se] += cnt[h[u]+i.fi]-1;",
				"    if (clear) {for (ll i = tin[u]; i <= tout[u]; i++) {cnt[h[euler[i]]] = 0;}}",
				"}",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> n;",
				"    for (ll i = 1; i <= n; i++)",
				"    {",
				"        ll x; cin >> x;",
				"        if (!x) root.pb(i);",
				"        else g[x].pb(i);",
				"    }",
				"    for (ll i : root) {dfs(i); build(); v.clear();} cin >> q;",
				"    for (ll i = 1; i <= q; i++) {ll a, b; cin >> a >> b; a = get(a,b); qx[a].pb({b,i});}",
				"    for (ll i : root) solve(i,1);",
				"    for (ll i = 1; i <= q; i++) cout << ans[i] << ' ';",
				"}"				
			]
		}
		// Heavy-Light Decomposition + ST
		"HLD_ST":
		{
			"prefix": ["hld_st"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long int ll;",
				"#define pb push_back",
				"#define fi first",
				"#define se second",
				"const ll mod = 1e9+7, mxn = 1e5+7;",
				"ll n, q, val[mxn];",
				"ll sz[mxn], h[mxn], pr[mxn], chain_head[mxn], chain[mxn], pos[mxn], arr[mxn], curpos, curchain; //hld",
				"ll st[mxn<<2]; //segment tree",
				"vector<vector<ll>> g(mxn);",
				"//segment tree",
				"void build(ll id, ll l, ll r)",
				"{",
				"    if (l == r) {st[id] = val[arr[l]]; return;}",
				"    ll m = (r+l)>>1;",
				"    build(id<<1,l,m); build((id<<1)+1,m+1,r);",
				"    st[id] = max(st[id<<1],st[(id<<1)+1]);",
				"}",
				"void update(ll id, ll l, ll r, ll p, ll v)",
				"{",
				"    if (l > p || r < p) return;",
				"    if (l == r) {st[id] = v; return;}",
				"    ll m = (r+l)>>1;",
				"    update(id<<1,l,m,p,v); update((id<<1)+1,m+1,r,p,v);",
				"    st[id] = max(st[id<<1],st[(id<<1)+1]); ",
				"}",
				"ll get(ll id, ll l, ll r, ll u, ll v)",
				"{",
				"    if (r < u || v < l) return 0;",
				"    if (u <= l && r <= v) return st[id];",
				"    ll m = (r+l)>>1;",
				"    return max(get(id<<1,l,m,u,v),get((id<<1)+1,m+1,r,u,v)); ",
				"}",
				"//hld",
				"void dfs(ll u, ll v)",
				"{",
				"    sz[u] = 1;",
				"    for (ll i : g[u]) ",
				"    {",
				"        if (i != v) ",
				"        {",
				"            pr[i] = u; h[i] = h[u] + 1; ",
				"            dfs(i,u); ",
				"            sz[u] += sz[i];",
				"        }",
				"    }",
				"}",
				"void hld(ll u, ll v)",
				"{",
				"    if (!chain_head[curchain]) chain_head[curchain] = u;",
				"    chain[u] = curchain; pos[u] = curpos; arr[curpos] = u; curpos++;",
				"    ll nxt = 0;",
				"    for (ll i : g[u]) {if (i != v && (!nxt || sz[i] > sz[nxt])) {nxt = i;}}",
				"    if (nxt) hld(nxt,u);",
				"    for (ll i : g[u]) {if (i != v && i != nxt) {curchain++; hld(i,u);}}",
				"}",
				"ll lca(ll u, ll v)",
				"{",
				"    while (chain[u] != chain[v])",
				"    {",
				"        if (chain[u] > chain[v]) u = pr[chain_head[chain[u]]];",
				"        else v = pr[chain_head[chain[v]]];",
				"    }",
				"    if (h[u] < h[v]) return u;",
				"    return v;",
				"}",
				"void upd(ll p, ll v) {update(1,1,n,pos[p],v);}",
				"ll query(ll u, ll v)",
				"{",
				"    ll lcax = lca(u,v), ans = 0;",
				"    while (chain[u] != chain[lcax]) ",
				"    {",
				"        ans = max(ans,get(1,1,n,pos[chain_head[chain[u]]],pos[u])); ",
				"        u = pr[chain_head[chain[u]]];",
				"    }",
				"    while (chain[v] != chain[lcax])",
				"    {",
				"        ans = max(ans,get(1,1,n,pos[chain_head[chain[v]]],pos[v]));",
				"        v = pr[chain_head[chain[v]]];",
				"    }",
				"    if (h[u] < h[v]) ans = max(ans,get(1,1,n,pos[u],pos[v]));",
				"    else ans = max(ans,get(1,1,n,pos[v],pos[u]));",
				"    return ans;",
				"}",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> n >> q;",
				"    for (ll i = 1; i <= n; i++) cin >> val[i];",
				"    for (ll i = 1; i < n; i++)",
				"    {",
				"        ll a, b; cin >> a >> b;",
				"        g[a].pb(b); g[b].pb(a);",
				"    }",
				"    curpos = curchain = 1;  ",
				"    dfs(1,1); hld(1,1); build(1,1,n);",
				"    while (q--)",
				"    {",
				"        ll t; cin >> t;",
				"        if (t == 1) {ll u, x; cin >> u >> x; upd(u,x);}",
				"        else {ll u, v; cin >> u >> v; cout << query(u,v) << '\n';}",
				"    }",
				"}"				
			]
		}
		// Heavy-Light Decomposition + Lazy
		"HLD_LZ":
		{
			"prefix": ["hld_lz"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long int ll;",
				"#define pb push_back",
				"#define fi first",
				"#define se second",
				"const ll mod = 1e9+7, mxn = 1e5+7;",
				"ll n, q; //val[mxn];",
				"ll sz[mxn], h[mxn]; //precalc",
				"ll pr[mxn], chain_head[mxn], chain[mxn], pos[mxn], arr[mxn], curpos = 1, curchain = 1; //hld",
				"ll in[mxn], out[mxn], tdfs = 0; //ett",
				"struct node {ll cnt0, cnt1;};",
				"node st[mxn<<2]; ll lazy[mxn<<2]; //segment tree",
				"vector<vector<ll>> g(mxn);",
				"//segment tree",
				"void build(ll id, ll l, ll r)",
				"{",
				"    if (l == r) {st[id] = {1,0}; return;}",
				"    ll m = (r+l)>>1;",
				"    build(id<<1,l,m); build((id<<1)+1,m+1,r);",
				"    st[id] = {st[id<<1].cnt0+st[(id<<1)+1].cnt0,0};",
				"}",
				"void push(ll id, ll l, ll r)",
				"{",
				"    if (lazy[id] == -1) return;",
				"    if (lazy[id])",
				"    {",
				"        st[id<<1] = {0,st[id<<1].cnt0+st[id<<1].cnt1};",
				"        st[(id<<1)+1] = {0,st[(id<<1)+1].cnt0+st[(id<<1)+1].cnt1};",
				"        lazy[id<<1] = lazy[(id<<1)+1] = 1;",
				"    }",
				"    else",
				"    {",
				"        st[id<<1] = {st[id<<1].cnt0+st[id<<1].cnt1,0};",
				"        st[(id<<1)+1] = {st[(id<<1)+1].cnt0+st[(id<<1)+1].cnt1,0};",
				"        lazy[id<<1] = lazy[(id<<1)+1] = 0;",
				"    }",
				"    lazy[id] = -1;",
				"}",
				"void update(ll id, ll l, ll r, ll u, ll v, bool type)",
				"{",
				"    if (r < u || v < l) return;",
				"    if (u <= l && r <= v) ",
				"    {",
				"        if (type) st[id] = {0,st[id].cnt0+st[id].cnt1};",
				"        else st[id] = {st[id].cnt0+st[id].cnt1,0};",
				"        lazy[id] = type;",
				"        return;",
				"    }",
				"    ll m = (r+l)>>1;",
				"    push(id,l,r);",
				"    update(id<<1,l,m,u,v,type); update((id<<1)+1,m+1,r,u,v,type);",
				"    st[id] = {st[id<<1].cnt0+st[(id<<1)+1].cnt0,st[id<<1].cnt1+st[(id<<1)+1].cnt1};",
				"}",
				"ll get(ll id, ll l, ll r, ll u, ll v, bool type)",
				"{",
				"    if (r < u || v < l) return 0;",
				"    if (u <= l && r <= v)",
				"    {",
				"        ll ans = 0;",
				"        if (type)",
				"        {",
				"            ans += st[id].cnt0;",
				"            //st[id] = {0,ans+st[id].cnt1};",
				"        }",
				"        else",
				"        {",
				"            ans += st[id].cnt1;",
				"            //st[id] = {st[id].cnt0+ans,0};",
				"        }",
				"        //lazy[id] = type;",
				"        return ans;",
				"    }",
				"    ll m = (r+l)>>1;",
				"    push(id,l,r);",
				"    return get(id<<1,l,m,u,v,type)+get((id<<1)+1,m+1,r,u,v,type); ",
				"}",
				"//debugger",
				"ll dbg(ll id, ll l, ll r, ll u, ll v, bool type)",
				"{",
				"    if (r < u || v < l) return 0;",
				"    if (u <= l && r <= v)",
				"    {",
				"        ll ans = 0;",
				"        if (type)",
				"        {",
				"            ans += st[id].cnt0;",
				"            //st[id] = {0,ans+st[id].cnt1};",
				"        }",
				"        else",
				"        {",
				"            ans += st[id].cnt1;",
				"            //st[id] = {st[id].cnt0+ans,0};",
				"        }",
				"        //lazy[id] = type;",
				"        return ans;",
				"    }",
				"    ll m = (r+l)>>1;",
				"    push(id,l,r);",
				"    return get(id<<1,l,m,u,v,type)+get((id<<1)+1,m+1,r,u,v,type); ",
				"}",
				"//hld",
				"void dfs(ll u, ll v)",
				"{",
				"    sz[u] = 1;",
				"    for (ll i : g[u]) ",
				"    {",
				"        if (i != v) ",
				"        {",
				"            pr[i] = u; h[i] = h[u] + 1; ",
				"            dfs(i,u); ",
				"            sz[u] += sz[i];",
				"        }",
				"    }",
				"}",
				"void hld(ll u, ll v)",
				"{",
				"    if (!chain_head[curchain]) chain_head[curchain] = u;",
				"    chain[u] = curchain; pos[u] = curpos; arr[curpos] = u; curpos++; //hld",
				"    in[u] = ++tdfs;",
				"    ll nxt = 0;",
				"    for (ll i : g[u]) {if (i != v && (!nxt || sz[i] > sz[nxt])) {nxt = i;}}",
				"    if (nxt) hld(nxt,u);",
				"    for (ll i : g[u]) {if (i != v && i != nxt) {curchain++; hld(i,u);}}",
				"    out[u] = tdfs;",
				"}",
				"ll lca(ll u, ll v)",
				"{",
				"    while (chain[u] != chain[v])",
				"    {",
				"        if (chain[u] > chain[v]) u = pr[chain_head[chain[u]]];",
				"        else v = pr[chain_head[chain[v]]];",
				"    }",
				"    if (h[u] < h[v]) return u;",
				"    return v;",
				"}",
				"void upd(ll p, ll v) {update(1,1,n,pos[p],v,1);}",
				"ll query(ll u, ll v)",
				"{",
				"    ll lcax = lca(u,v), ans = 0;",
				"    while (chain[u] != chain[lcax]) ",
				"    {",
				"        ans = max(ans,get(1,1,n,pos[chain_head[chain[u]]],pos[u],1)); ",
				"        u = pr[chain_head[chain[u]]];",
				"    }",
				"    while (chain[v] != chain[lcax])",
				"    {",
				"        ans = max(ans,get(1,1,n,pos[chain_head[chain[v]]],pos[v],1));",
				"        v = pr[chain_head[chain[v]]];",
				"    }",
				"    if (h[u] < h[v]) ans = max(ans,get(1,1,n,pos[u],pos[v],1));",
				"    else ans = max(ans,get(1,1,n,pos[v],pos[u],1));",
				"    return ans;",
				"}",
				"//query",
				"void upd1(ll u)",
				"{",
				"    while (chain[u] != chain[1])",
				"    {",
				"        update(1,1,n,pos[chain_head[chain[u]]],pos[u],1);",
				"        u = pr[chain_head[chain[u]]];",
				"    }",
				"    update(1,1,n,1,pos[u],1);",
				"}",
				"void upd2(ll u) {update(1,1,n,in[u],out[u],0);}",
				"ll query1(ll u)",
				"{",
				"    ll ans = 0;",
				"    while (chain[u] != chain[1])",
				"    {",
				"        ans += get(1,1,n,pos[chain_head[chain[u]]],pos[u],1);",
				"        u = pr[chain_head[chain[u]]];",
				"    }",
				"    ans += get(1,1,n,1,pos[u],1);",
				"    return ans;",
				"}",
				"ll query2(ll u) {return get(1,1,n,in[u],out[u],0);}",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> n >> q; memset(lazy,-1,sizeof(lazy));",
				"    for (ll i = 1; i < n; i++)",
				"    {",
				"        ll a, b; cin >> a >> b;",
				"        g[a].pb(b); g[b].pb(a);",
				"    } ",
				"    dfs(1,1); hld(1,1); build(1,1,n);",
				"}"						
			]
		}
		// GSS On Tree
		"GSSTree":
		{
			"prefix": ["gss_tree"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef long long int ll;",
				"#define pb push_back",
				"#define fi first",
				"#define se second",
				"const ll mod = 1e9+7, mxn = 1e5+14;",
				"//main var",
				"ll n, q, valx[mxn];",
				"vector<vector<ll>> g(mxn);",
				"//segment tree var",
				"struct node {ll ans, sum, left, right;};",
				"node merge_node(node a, node b)",
				"{",
				"    node ans = {max({a.ans,b.ans,a.right+b.left}),",
				"                a.sum+b.sum,",
				"                max(a.left,a.sum+b.left),",
				"                max(b.right,b.sum+a.right)};",
				"    return ans;",
				"}",
				"node st[mxn<<2];",
				"ll lazy[mxn<<2];",
				"//heavy-light decomposition var",
				"ll sz[mxn], h[mxn], pr[mxn]; //precalc",
				"ll chain[mxn], chain_head[mxn], pos[mxn], arr[mxn]; //hld",
				"ll curpos = 1, curchain = 1; //hld cnt var",
				"//segment tree",
				"void build(ll id, ll l, ll r)",
				"{",
				"    if (l == r) ",
				"    {",
				"        if (valx[arr[l]] < 0)",
				"        {   ",
				"            st[id] = {0, valx[arr[l]],",
				"                      0, 0};",
				"        }",
				"        else",
				"        {",
				"            st[id] = {valx[arr[l]], valx[arr[l]],",
				"                      valx[arr[l]], valx[arr[l]]};",
				"        }",
				"        return;",
				"    }",
				"    ll m = (r+l)>>1;",
				"    build(id<<1,l,m); build((id<<1)+1,m+1,r);",
				"    st[id] = merge_node(st[id<<1],",
				"                        st[(id<<1)+1]);",
				"}",
				"void push(ll id, ll l, ll r)",
				"{",
				"    if (lazy[id] == (ll)(-1e18)) return;",
				"    ll m = (r+l)>>1;",
				"    if (lazy[id] < 0)",
				"    {",
				"        st[id<<1] = {0, lazy[id]*(m-l+1),",
				"                     0, 0};",
				"        st[(id<<1)+1] = {0, lazy[id]*(r-m),",
				"                         0, 0};",
				"    }   ",
				"    else",
				"    {",
				"        st[id<<1] = {lazy[id]*(m-l+1), lazy[id]*(m-l+1),",
				"                     lazy[id]*(m-l+1), lazy[id]*(m-l+1)};",
				"        st[(id<<1)+1] = {lazy[id]*(r-m), lazy[id]*(r-m),",
				"                         lazy[id]*(r-m), lazy[id]*(r-m)};",
				"    }",
				"    lazy[id<<1] = lazy[id]; lazy[(id<<1)+1] = lazy[id];",
				"    lazy[id] = (ll)(-1e18);",
				"}",
				"void update(ll id, ll l, ll r, ll u, ll v, ll val)",
				"{",
				"    if (r < u || v < l) return;",
				"    if (u <= l && r <= v) ",
				"    {",
				"        if (val < 0)",
				"        {",
				"            st[id] = {0, val*(r-l+1), ",
				"                      0, 0};",
				"        }",
				"        else",
				"        {",
				"            st[id] = {val*(r-l+1), val*(r-l+1),",
				"                      val*(r-l+1), val*(r-l+1)};",
				"        }",
				"        lazy[id] = val;",
				"        return;",
				"    }",
				"    ll m = (r+l)>>1;",
				"    push(id,l,r);",
				"    update(id<<1,l,m,u,v,val); update((id<<1)+1,m+1,r,u,v,val);",
				"    st[id] = merge_node(st[id<<1],",
				"                        st[(id<<1)+1]);",
				"}",
				"node get(ll id, ll l, ll r, ll u, ll v)",
				"{",
				"    if (r < u || v < l) return {0, 0,",
				"                                0, 0};",
				"    if (u <= l && r <= v) return st[id];",
				"    ll m = (r+l)>>1;",
				"    push(id,l,r);",
				"    return merge_node(get(id<<1,l,m,u,v),",
				"                      get((id<<1)+1,m+1,r,u,v));",
				"}",
				"//heavy-light decomposition",
				"void dfs(ll u, ll v)",
				"{",
				"    sz[u] = 1;",
				"    for (ll i : g[u])",
				"    {",
				"        if (i != v)",
				"        {",
				"            pr[i] = u; h[i] = h[u]+1;",
				"            dfs(i,u);",
				"            sz[u] += sz[i];",
				"        }",
				"    }",
				"}",
				"void hld(ll u, ll v)",
				"{",
				"    if (!chain_head[curchain]) chain_head[curchain] = u;",
				"    chain[u] = curchain; pos[u] = curpos;",
				"    arr[curpos] = u; curpos++;",
				"    ll nxt = 0;",
				"    for (ll i : g[u])",
				"    {",
				"        if (i != v)",
				"        {",
				"            if (!nxt) nxt = i;",
				"            else if (sz[i] > sz[nxt]) nxt = i;",
				"        }",
				"    }",
				"    if (nxt) hld(nxt,u);",
				"    for (ll i : g[u])",
				"    {",
				"        if (i != v && i != nxt)",
				"        {",
				"            curchain++;",
				"            hld(i,u);",
				"        }",
				"    }",
				"}",
				"ll lca(ll u, ll v)",
				"{",
				"    while (chain[u] != chain[v])",
				"    {",
				"        if (chain[u] > chain[v]) u = pr[chain_head[chain[u]]];",
				"        else v = pr[chain_head[chain[v]]];",
				"    }",
				"    if (h[u] < h[v]) return u;",
				"    return v;",
				"}",
				"void query_update(ll u, ll v, ll x)",
				"{",
				"    ll lcax = lca(u,v);",
				"    while (chain[u] != chain[lcax])",
				"    {",
				"        update(1,1,n,pos[chain_head[chain[u]]],pos[u],x);",
				"        u = pr[chain_head[chain[u]]];",
				"    }",
				"    while (chain[v] != chain[lcax])",
				"    {",
				"        update(1,1,n,pos[chain_head[chain[v]]],pos[v],x);",
				"        v = pr[chain_head[chain[v]]];",
				"    }",
				"    if (h[u] < h[v]) update(1,1,n,pos[u],pos[v],x);",
				"    else update(1,1,n,pos[v],pos[u],x);",
				"}",
				"node query_get(ll u, ll v)",
				"{",
				"    ll lcax = lca(u,v);",
				"    node ans1 = {0, 0,",
				"                 0, 0};",
				"    node ans2 = ans1;",
				"    while (chain[u] != chain[lcax])",
				"    {",
				"        ans1 = merge_node(get(1,1,n,pos[chain_head[chain[u]]],pos[u]),ans1);",
				"        u = pr[chain_head[chain[u]]];",
				"    }",
				"    while (chain[v] != chain[lcax])",
				"    {",
				"        ans2 = merge_node(get(1,1,n,pos[chain_head[chain[v]]],pos[v]),ans2);",
				"        v = pr[chain_head[chain[v]]];",
				"    }",
				"    if (h[u] < h[v]) ans2 = merge_node(get(1,1,n,pos[u],pos[v]),ans2);",
				"    else ans1 = merge_node(get(1,1,n,pos[v],pos[u]),ans1);",
				"    swap(ans2.right,ans2.left);",
				"    return merge_node(ans2,ans1);",
				"}",
				"//main",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> n >> q;",
				"    for (ll i = 0; i <= ((n+7)<<2); i++) lazy[i] = (ll)(-1e18);",
				"    for (ll i = 1; i <= n; i++) cin >> valx[i];",
				"    for (ll i = 1; i < n; i++)",
				"    {",
				"        ll a, b; cin >> a >> b;",
				"        g[a].pb(b); g[b].pb(a);",
				"    }",
				"    dfs(1,1); hld(1,1); build(1,1,n);",
				"    while (q--)",
				"    {",
				"        ll t; cin >> t;",
				"        if (t == 1)",
				"        {",
				"            ll u, v; cin >> u >> v;",
				"        }",
				"        else",
				"        {",
				"            ll u, v, x; cin >> u >> v >> x;",
				"        }",
				"    }",
				"}"				
			]
		}
		// Centroid Decompositon
		"CenDecom":
		{
			"prefix": ["cen_decom"],
			"body":
			[
				"ll sz[mxn];",
				"bool del[mxn];",
				"vector<vector<ll>> g(mxn);",
				"void dfs_sz(ll u, ll v) {sz[u] = 1; for (ll i : g[u]) {if (i != v && !del[i]) {dfs_sz(i,u); sz[u] += sz[i];}}}",
				"ll dfs_ctr(ll u, ll v, ll szx) {for (ll i : g[u]) {if (i != v && !del[i] && sz[i] > szx/2) {return dfs_ctr(i,u,szx);}} return u;}",
				"void upd(ll u) ",
				"{",
				"",
				"}",
				"void solve(ll u)",
				"{",
				"    dfs_sz(u,u); ll n_root = dfs_ctr(u,u,sz[u]);",
				"    upd(n_root); del[n_root] = 1;",
				"    for (ll i : g[n_root]) {if (!del[i]) solve(i);}",
				"}"				
			]
		}
		// Strongly Connected Component
		"scc":
		{
			"prefix": ["scc"],
			"body":
			[
				"ll n, m, scc[mxn], low[mxn], num[mxn], cntscc = 0, tdfs = 0;",
				"bool del[mxn];",
				"vector<vector<ll>> g(500005);",
				"stack<ll> s;",
				"void dfs(ll u)",
				"{",
				"    num[u] = low[u] = ++tdfs;",
				"    s.push(u);",
				"    for (auto i : g[u])",
				"    {",
				"        if (del[i]) continue;",
				"        if (!num[i])",
				"        {",
				"            dfs(i);",
				"            low[u] = min(low[u],low[i]);",
				"        }",
				"        else low[u] = min(low[u],num[i]);",
				"    }",
				"    if (num[u] == low[u])",
				"    {",
				"        cntscc++;",
				"        ll vi = s.top(), cnt = 1; s.pop();",
				"        while (vi != u)",
				"        {",
				"            cnt++; del[vi] = 1; scc[vi] = cntscc;",
				"            vi = s.top(); s.pop();",
				"        }",
				"        del[vi] = 1; scc[u] = cntscc; ",
				"        sz[cntscc] = cnt;",
				"    }",
				"}"				
			]
		}
		// Bridge And Joint
		"tarjan":
		{
			"prefix": ["tarjan"],
			"body":
			[
				"void dfs(ll u, ll v)",
				"{",
				"    ll child = 0;",
				"    tdfs++; num[u] = tdfs;",
				"    low[u] = num[u];",
				"    for (ll i : g[u])",
				"    {",
				"        if (i == v) continue;",
				"        if (!num[i])",
				"        {",
				"            dfs(i,u);",
				"            low[u] = min(low[i],low[u]);",
				"            if (low[i] == num[i]) bridge++;",
				"            child++;",
				"            if (u == pre)",
				"            {",
				"                if (child > 1) joint[u] = true;",
				"            }",
				"            else if (low[i] >= num[u]) joint[u] = true;",
				"        }",
				"        else low[u] = min(low[u],num[i]);",
				"    }",
				"    tail[u] = tdfs;",
				"}"							
			]
		}
		// LCA
		"lca":
		{
			"prefix": ["lca"],
			"body":
			[
				"ll n, q, h[mxn], up[mxn][20], ans[mxn];",
				"vector<vector<ll>> g(mxn);",
				"void dfs(ll u, ll v)",
				"{",
				"    for (ll i : g[u])",
				"    {",
				"        if (i != v)",
				"        {",
				"            h[i] = h[u]+1; up[i][0] = u;",
				"            dfs(i,u);",
				"        }",
				"    }",
				"}",
				"void build_lca()",
				"{",
				"    for (ll i = 1; i <= n; i++)",
				"    {",
				"        for (ll j = 1; j <= 19; j++) up[i][j] = up[up[i][j-1]][j-1];",
				"    }",
				"}",
				"ll lca(ll a, ll b)",
				"{",
				"    if (h[a] != h[b])",
				"    {",
				"        if (h[a] < h[b]) swap(a,b);",
				"        ll k = h[a]-h[b];",
				"        for (ll i = __lg(k); i >= 0; i--)",
				"        {",
				"            if (k >> i & 1) a = up[a][i];",
				"        }",
				"    }",
				"    if (a == b) return a;",
				"    for (ll i = 19; i >= 0; i--) ",
				"    {",
				"        if (up[a][i] != up[b][i]) {a = up[a][i]; b = up[b][i];}",
				"    }",
				"    return up[a][0];",
				"}"				
			]
		}
		// Binlift

		// Euler Tour On Tree

	// String
		// Hashing
		"hash":
		{
			"prefix": ["hash"],
			"body":
			[
				"const ll mod = 1e9+7;",
				"const ll mxn = 1e6+7;",
				"const int base = 31;",
				"ll POW[mxn], hashT[mxn];",
				"ll gethashT(ll i, ll j) {return (hashT[j]-hashT[i-1]*POW[j-i+1]+mod*mod)%mod;}",
				"string T, P;",
				"ll hashP = 0;",
				"void createhashT()",
				"{",
				"    T = " " + T;",
				"    POW[0] = 1;",
				"    for (ll i = 1; i < T.length(); i++) POW[i] = (POW[i-1]*base)%mod;",
				"    for (ll i = 1; i < T.length(); i++) hashT[i] = (hashT[i-1]*base+T[i]-'a'+1)%mod;",
				"}",
				"void createhashP()",
				"{",
				"    P = " " + P;",
				"    for (ll i = 1; i < P.length(); i++) hashP = (hashP*base+P[i]-'a'+1)%mod;",
				"}"				
			]
		}
		// KMP
		"KMP":
		{
			"prefix": ["kmp"],
			"body":
			[
				"vector<ll> prefix_function(string& s)",
				"{",
				"    ll n = s.size();",
				"    vector<ll> pi(n);",
				"    for (ll i = 1, j = 0; i < n; i++)",
				"    {",
				"        while (j && s[j] != s[i]) j = pi[j-1];",
				"        j += (s[j] == s[i]); pi[i] = j;",
				"    }",
				"    return pi;",
				"}"
			]
		}
		// KMP Automaton
		"KMP Automaton":
		{
			"prefix": ["kmp_automaton"],
			"body":
			[
				"vector<ll> prefix_function(string& s)",
				"{",
				"    ll n = s.size();",
				"    vector<ll> pi(n);",
				"    for (ll i = 1, j = 0; i < n; i++)",
				"    {",
				"        while (j && s[j] != s[i]) j = pi[j-1];",
				"        j += (s[j] == s[i]); pi[i] = j;",
				"    }",
				"    return pi;",
				"}",
				"vector<vector<ll>> automaton(string& s)",
				"{",
				"    s += '#';",
				"    ll n = s.size();",
				"    vector<ll> pi = prefix_function(s);",
				"    vector<vector<ll>> aut(n,vector<ll>(26));",
				"    for (ll i = 0; i < n; i++)",
				"    {",
				"        for (ll j = 0; j < 26; j++)",
				"        {",
				"            if (i && ('A'+j) != s[i]) aut[i][j] = aut[pi[i-1]][j];",
				"            else aut[i][j] = i+(('A'+j) == s[i]);",
				"        }",
				"    }",
				"    return aut;",
				"}"
			]
		}
		// Z-Function
		"Z":
		{
			"prefix": ["z"],
			"body":
			[
				"vector<ll> z_function(string& s)",
				"{",
				"    ll n = s.size();",
				"    vector<ll> z(n);",
				"    for (ll i = 1, l = 0, r = 0; i < n; i++)",
				"    {",
				"        if (i <= r) z[i] = min(r-i+1, z[i-l]);",
				"        while (i+z[i] < n && s[z[i]] == s[i+z[i]]) ++z[i];",
				"        if (i+z[i]-1 > r) {l = i, r = i+z[i]-1;}",
				"    }",
				"    return z;",
				"}"				
			]
		}

	// Flow
		// Ford-Fukerson - Edmords-Karp
		"Edmords-Karp":
		{
			"prefix": ["karp"],
			"body":
			[
				"ll n, m, capacity[mxn][mxn];",
				"vector<vector<ll>> g(mxn);",
				"ll bfs(ll s, ll t, vector<ll>& pr)",
				"{",
				"    fill(pr.begin(),pr.end(),-1);",
				"    pr[s] = -2; queue<pair<ll,ll>> q; q.push({s,1e18});",
				"    while (!q.empty())",
				"    {",
				"        ll u = q.front().fi, flow = q.front().se; q.pop();",
				"        for (ll i : g[u])",
				"        {",
				"            if (pr[i] == -1 && capacity[u][i])",
				"            {",
				"                pr[i] = u;",
				"                ll new_flow = min(flow,capacity[u][i]);",
				"                if (i == t) return new_flow;",
				"                q.push({i,new_flow});",
				"            }",
				"        }",
				"    }",
				"    return 0;",
				"}",
				"ll max_flow(ll s, ll t)",
				"{",
				"    ll flow = 0, new_flow;",
				"    vector<ll> pr(n+7); new_flow = bfs(s,t,pr);",
				"    while (new_flow)",
				"    {",
				"        flow += new_flow;",
				"        ll u = t;",
				"        while (u != s)",
				"        {",
				"            ll prv = pr[u];",
				"            capacity[prv][u] -= new_flow;",
				"            capacity[u][prv] += new_flow;",
				"            u = prv;",
				"        }",
				"        new_flow = bfs(s,t,pr);",
				"    }",
				"    return flow;",
				"}"
			]
		}
		// Dinitz
		"Dinitz":
		{
			"prefix": ["dinitz"],
			"body":
			[
				"ll n, m, capacity[mxn][mxn], lv[mxn];",
				"vector<vector<ll>> g(mxn);",
				"void bfs_lv(ll s)",
				"{",
				"    fill(lv+1,lv+n+1,-1); lv[s] = 0;",
				"    queue<ll> q; q.push(s);",
				"    while (!q.empty())",
				"    {",
				"        ll u = q.front(); q.pop();",
				"        for (ll i : g[u])",
				"        {",
				"            if (lv[i] == -1 && capacity[u][i]) ",
				"            {",
				"                lv[i] = lv[u]+1;",
				"                q.push(i);",
				"            }",
				"        }",
				"    }",
				"}",
				"ll bfs(ll s, ll t, vector<ll>& pr)",
				"{",
				"    fill(pr.begin(),pr.end(),-1);",
				"    pr[s] = -2; queue<pair<ll,ll>> q; q.push({s,1e18});",
				"    while (!q.empty())",
				"    {",
				"        ll u = q.front().fi, flow = q.front().se; q.pop();",
				"        for (ll i : g[u])",
				"        {",
				"            if (pr[i] == -1 && capacity[u][i] && lv[i] == lv[u]+1)",
				"            {",
				"                pr[i] = u;",
				"                ll new_flow = min(flow,capacity[u][i]);",
				"                if (i == t) return new_flow;",
				"                q.push({i,new_flow});",
				"            }",
				"        }",
				"    }",
				"    return 0;",
				"}",
				"ll max_flow(ll s, ll t)",
				"{",
				"    ll flow = 0, new_flow;",
				"    vector<ll> pr(n+7); ",
				"    while (1)",
				"    {",
				"        bfs_lv(s);",
				"        new_flow = bfs(s,t,pr); ",
				"        if (!new_flow) break;",
				"        while (new_flow)",
				"        {",
				"            flow += new_flow;",
				"            ll u = t;",
				"            while (u != s)",
				"            {",
				"                ll prv = pr[u];",
				"                capacity[prv][u] -= new_flow;",
				"                capacity[u][prv] += new_flow;",
				"                u = prv;",
				"            }",
				"            new_flow = bfs(s,t,pr);",
				"        }   ",
				"    }",
				"    return flow;",
				"}"
			]
		}
		"Manacher":
		{
			"prefix": ["manacher"],
			"body":
			[
				"vector<ll> manacher_odd(string s)",
				"{",
				"    string t; ll n = s.size();",
				"    t += '$', t += s, t += '^'; swap(s,t);",
				"    vector<ll> p(n+2);",
				"    for (ll i = 1, l = 1, r = 1; i <= n; i++)",
				"    {",
				"        p[i] = max(0LL,min(r-i, p[l+r-i]));",
				"        while (s[i-p[i]] == s[i+p[i]]) p[i]++;",
				"        if (i+p[i] > r) l = i-p[i], r = i+p[i];",
				"    }",
				"    return vector<ll>(p.begin()+1,p.end()-1);",
				"}",
				"vector<ll> manacher(string s)",
				"{",
				"    string t; t.clear(); ",
				"    for (char c : s) {t += '#', t += c;}",
				"    t += '#'; vector<ll> p = manacher_odd(t);",
				"    return vector<ll>(p.begin()+1,p.end()-1);",
				"}"							
			]
		}
		"Dinitz2":
		{
			"prefix": ["dinitz2"],
			"body":
			[
				"struct flow_edge",
				"{",
				"    ll v, u, cap, flow = 0;",
				"    flow_edge(ll v, ll u, ll cap) : v(v), u(u), cap(cap) {}",
				"};",
				"struct dinitz",
				"{",
				"    const ll flow_inf = 1e18;",
				"    vector<flow_edge> edges; vector<vector<ll>> g;",
				"    ll n, m = 0, s, t;",
				"    vector<ll> lv, ptr; queue<ll> q;",
				"    dinitz(ll n, ll s, ll t) : n(n), s(s), t(t) {g.resize(n); lv.resize(n); ptr.resize(n);}",
				"    void add(ll v, ll u, ll cap)",
				"    {",
				"        edges.emplace_back(v,u,cap); edges.emplace_back(u,v,0);",
				"        g[v].pb(m); g[u].pb(m+1); m += 2;",
				"    }",
				"    bool bfs()",
				"    {",
				"        while (!q.empty())",
				"        {",
				"            ll v = q.front(); q.pop();",
				"            for (ll i : g[v])",
				"            {",
				"                if (edges[i].cap-edges[i].flow < 1) continue;",
				"                if (lv[edges[i].u] != -1) continue;",
				"                lv[edges[i].u] = lv[v]+1; q.push(edges[i].u);",
				"            }",
				"        }",
				"        return (lv[t] != -1);",
				"    }",
				"    ll dfs(ll v, ll pushed)",
				"    {",
				"        if (!pushed) return 0;",
				"        if (v == t) return pushed;",
				"        for (ll& cid = ptr[v]; cid < g[v].size(); cid++)",
				"        {",
				"            ll i = g[v][cid], u = edges[i].u;",
				"            if (lv[v]+1 != lv[u] || edges[i].cap-edges[i].flow < 1) continue;",
				"            ll tr = dfs(u, min(pushed, edges[i].cap-edges[i].flow));",
				"            if (!tr) continue;",
				"            edges[i].flow += tr; edges[i^1].flow -= tr;",
				"            return tr;",
				"        }",
				"        return 0;",
				"    }",
				"    ll flow()",
				"    {",
				"        ll f = 0;",
				"        while (1)",
				"        {",
				"            fill(lv.begin(),lv.end(),-1); lv[s] = 0; q.push(s);",
				"            if (!bfs()) break;",
				"            fill(ptr.begin(),ptr.end(),0);",
				"            while (ll pushed = dfs(s,flow_inf)) f += pushed;",
				"        }",
				"        return f;",
				"    }",
				"};"				
			]
		}
		// Bipartite Matching
		"Kuhn":
		{
			"prefix": ["kuhn"],
			"body":
			[
				"ll n, m, assign[mxn], T = 1, vis[mxn];",
				"vector<vector<ll>> g(mxn);",
				"bool f(ll u)",
				"{",
				"    for (ll i : g[u])",
				"    {",
				"        if (vis[i] != T)",
				"        {",
				"            vis[i] = T;",
				"            if ((!assign[i] || f(assign[i])))",
				"            {",
				"                assign[i] = u;",
				"                return 1;",
				"            }",
				"        }",
				"    }",
				"    return 0;",
				"}",
				"vector<ll> v;",
				"void match()",
				"{",
				"    ll ans = 0;",
				"    for (ll i = 1; i <= n; i++) v.pb(i);",
				"    mt19937 d(time(0)); shuffle(v.begin(),v.end(),d);",
				"    for (ll i : v) {ans += f(i); T++;}",
				"    cout << ans;",
				"}"
			]
		}
	// Geometry
		// General
		"geo":
		{
			"prefix": ["geo"],
			"body":
			[
				"struct point {ld x, y;};",
				"struct line {ld a, b, c;};",
				"struct vct {ld x, y;};",
				"struct segment{};",
				"struct ray{};",
				"ld dist(point a, point b) {return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}",
				"ld dist(point a, line b) {}",
				"ld triangle_area(point a, point b, point c)",
				"{",
				"    ld d1 = dist(a,b), d2 = dist(b,c), d3 = dist(c,a), p = (d1+d2+d3)/2, ",
				"        s = sqrt(p*(p-d1)*(p-d2)*(p-d3));",
				"    return s;",
				"}",
				"point intersection(line x, line y) {return {(y.c*x.b-x.c*y.b)/(y.b*x.a-x.b*y.a),(x.c*y.a-y.c*x.a)/(y.b*x.a-x.b*y.a)};}",
				"line get_line(point a, point b)",
				"{",
				"    ld ax = a.y-b.y, bx = b.x-a.x, cx = (a.x*(b.y-a.y)+a.y*(a.x-b.x));",
				"    return {ax,bx,cx};",
				"}",
				"vct ppdc_vct(line x) {return {x.a,x.b};}",
				"vct prl_vct(line x) {return {-x.b,x.a};}",
				"line get_line(point a, vct b)",
				"{",
				"    ",
				"}",
				"line get_ppdc_line(point a, vct b)",
				"{",
				"    ",
				"}",
				"line bisector(line x, line y)",
				"{",
				"    ld ax = (x.a*sqrt(y.a*y.a+y.b*y.b)+y.a*sqrt(x.a*x.a+x.b*x.b)), ",
				"       bx = (x.b*sqrt(y.a*y.a+y.b*y.b)+y.b*sqrt(x.a*x.a+x.b*x.b)), ",
				"       cx = (x.c*sqrt(y.a*y.a+y.b*y.b)+y.c*sqrt(x.a*x.a+x.b*x.b));",
				"    return {ax,bx,cx};",
				"}",
				"bool lie_on_segment(point a, segment b) {}",
				"bool lie_on_ray(point a, ray b) {}",
				"bool lie_on_line(point a, line b) {}",
				"bool same_plane(point a, point b, line c) {}",
				"ld dist(point a, segment b) {}",
				"ld dist(point a, ray b) {}",
				"ld dist(segment a, segment b) {}",
				"ld dist(ray a, ray b) {}"				
			]
		}
		// Convex Hull
		"Convex_Hull":
		{
			"prefix": ["convex_hull"],
			"body":
			[
				"struct point {ld x, y;};",
				"ll orientation(point a, point b, point c) {ld v = a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y); return (v>0)-(v<0);}",
				"bool cw(point a, point b, point c, bool icd_cln = 0) {ll o = orientation(a,b,c); return (o == -1 || (icd_cln && !o));}",
				"bool ccw(point a, point b, point c, bool icd_cln = 0) {ll o = orientation(a,b,c); return (o == 1 || (icd_cln && !o));}",
				"struct cmp {bool operator() (point a, point b) const {if (a.x != b.x) {return a.x < b.x;} return a.y < b.y;}};",
				"struct convex_hull",
				"{",
				"    vector<point> hull;",
				"    convex_hull(vector<point>& a, bool icd_cln)",
				"    {",
				"        if (a.size() == 1) return;",
				"        sort(a.begin(),a.end(),cmp()); point p1 = a[0], p2 = a.back();",
				"        vector<point> up_hull, down_hull; up_hull.pb(p1); down_hull.pb(p1);",
				"        for (ll i = 1; i < a.size(); i++)",
				"        {",
				"            if (i == a.size()-1 || cw(p1,a[i],p2,icd_cln))",
				"            {",
				"                while (up_hull.size() >= 2 && !cw(up_hull[up_hull.size()-2],up_hull.back(),a[i],icd_cln)) up_hull.pop_back();",
				"                up_hull.pb(a[i]);",
				"            }",
				"            if (i == a.size()-1 || ccw(p1,a[i],p2,icd_cln))",
				"            {",
				"                while (down_hull.size() >= 2 && !ccw(down_hull[down_hull.size()-2],down_hull.back(),a[i],icd_cln)) down_hull.pop_back();",
				"                down_hull.pb(a[i]);",
				"            }",
				"        }",
				"        if (icd_cln && up_hull.size() == a.size()) {reverse(a.begin(),a.end()); for (point i : a) {hull.pb(i);} a.clear(); return;}",
				"        a.clear(); for (point i : up_hull) {hull.pb(i);} for (ll i = down_hull.size()-2; i; i--) hull.pb(down_hull[i]);",
				"    }",
				"};",
				"struct dynamic_convex_hull",
				"{",
				"    set<point,cmp> up_hull, down_hull;",
				"    bool check_up_hull(const point& pt)",
				"    {",
				"        set<point>::iterator it = up_hull.lower_bound(pt);",
				"        if (it != up_hull.end() && (*it).x == pt.x && (*it).y == pt.y) return 0;",
				"        if (it != up_hull.begin() && it != up_hull.end() && !cw(*prev(it),pt,*it)) return 0;",
				"        return 1;",
				"    }",
				"    bool check_down_hull(const point& pt)",
				"    {",
				"        set<point>::iterator it = down_hull.lower_bound(pt);",
				"        if (it != down_hull.end() && (*it).x == pt.x && (*it).y == pt.y) return 0;",
				"        if (it != down_hull.begin() && it != down_hull.end() && !ccw(*prev(it),pt,*it)) return 0;",
				"        return 1;",
				"    }",
				"    void insert_up_hull(const point& pt)",
				"    {",
				"        set<point>::iterator it1 = up_hull.lower_bound(pt), it2 = it1;",
				"        if (it1 != up_hull.begin()) {it1--; while (it1 != up_hull.begin() && !cw(*prev(it1),*it1,pt)) it1 = prev(up_hull.erase(it1));}",
				"        if (it2 != up_hull.end()) {while (it2 != prev(up_hull.end()) && !cw(pt,*it2,*next(it2))) {it2 = up_hull.erase(it2);}}",
				"        up_hull.insert(pt);",
				"    }",
				"    void insert_down_hull(const point& pt)",
				"    {",
				"        set<point>::iterator it1 = down_hull.lower_bound(pt), it2 = it1;",
				"        if (it1 != down_hull.begin()) {it1--; while (it1 != down_hull.begin() && !ccw(*prev(it1),*it1,pt)) it1 = prev(down_hull.erase(it1));}",
				"        if (it2 != down_hull.end()) {while (it2 != prev(down_hull.end()) && !ccw(pt,*it2,*next(it2))) {it2 = down_hull.erase(it2);}}",
				"        down_hull.insert(pt);",
				"    }",
				"};"				
			]
		}
	// Math
		// Binary Power
		"bpow":
		{
			"prefix": ["bpow"],
			"body":
			[
				"ll bpow(ll a, ll b)",
				"{",
				"    if (!b) return 1;",
				"    ll m = bpow(a,b/2);",
				"    if (b&1) return (((m*m)%mod)*a)%mod;",
				"    return (m*m)%mod;",
				"}"				
			]
		}
		// Combinatorics
		"combi":
		{
			"prefix": ["combi"],
			"body":
			[
				"ll fac[mxn];",
				"void precalc_fac()",
				"{",
				"    fac[0] = 1;",
				"    for (ll i = 1; i <= mxn; i++) fac[i] = (fac[i-1]*i)%mod;",
				"}",
				"ll bpow(ll a, ll b)",
				"{",
				"    if (!b) return 1;",
				"    ll m = bpow(a,b/2);",
				"    if (b&1) return (((m*m)%mod)*a)%mod;",
				"    return (m*m)%mod;",
				"}",
				"ll C(ll a, ll b) // C(n,k)",
				"{",
				"    return (fac[a]*bpow((fac[a-b]*fac[b])%mod,mod-2))%mod;",
				"}"							
			]
		}
		// Catalan
		"cat":
		{
			"prefix": ["cat"],
			"body":
			[
				"ll fac[mxn];",
				"void precalc_fac()",
				"{",
				"    fac[0] = 1;",
				"    for (ll i = 1; i <= mxn; i++) fac[i] = (fac[i-1]*i)%mod;",
				"}",
				"ll bpow(ll a, ll b)",
				"{",
				"    if (!b) return 1;",
				"    ll m = bpow(a,b/2);",
				"    if (b&1) return (((m*m)%mod)*a)%mod;",
				"    return (m*m)%mod;",
				"}",
				"ll C(ll a, ll b) // C(n,k)",
				"{",
				"    return (fac[a]*bpow((fac[a-b]*fac[b])%mod,mod-2))%mod;",
				"}",
				"ll cat(ll n)",
				"{",
				"    return (C(2*n,n)*bpow(n+1,mod-2))%mod;",
				"}"				
			]
		}
		// IE

		// Sieve
		"Sieve":
		{
			"prefix": ["sieve"],
			"body":
			[
				"bool pp[mxn];",
				"void sieve()",
				"{",
				"    for (ll i = 2; i*i < mxn; i++)",
				"    {",
				"        if (!pp[i])",
				"        {",
				"            for (ll j = i*i; j < mxn; j += i) pp[j] = 1;",
				"        }",
				"    }",
				"}"				
			]
		}
		// SPF
		"spf":
		{
			"prefix": ["spf"],
			"body":
			[
				"ll spf[mxn];",
				"void sieve()",
				"{",
				"    for (ll i = 1; i < mxn; i++) spf[i] = i;",
				"    for (ll i = 2; i*i < mxn; i++)",
				"    {",
				"        if (spf[i] == i)",
				"        {",
				"            for (ll j = i*i; j < mxn; j += i) spf[j] = min(spf[j],i);",
				"        }",
				"    }",
				"}"
			]
		}
		// Single Phi
		"sphi":
		{
			"prefix": ["phi_s"],
			"body":
			[
				"ll n_phi(ll n) {ll phi_n = n; for (ll i = 2; i*i <= n; i++) {if (n % i == 0) {while (n % i == 0) {n /= i;} phi_n -= phi_n / i;}} if (n > 1) {phi_n -= phi_n / n;} return phi_n;}"
			]
		}
		// Phi Range
		"rphi":
		{
			"prefix": ["phi_r"],
			"body":
			[
				"ll phi[mxn];",
				"void phi_range(ll n)",
				"{",
				"    for (ll i = 1; i <= n; i++) phi[i] = i;",
				"    for (ll i = 2; i <= n; i++)",
				"    {",
				"        if (phi[i] == i)",
				"        {",
				"            for (ll j = i; j <= n; j += i)",
				"            {",
				"                phi[j] -= phi[j] / i;",
				"            }",
				"        }",
				"    }",
				"}"				
			]
		}
	// DP
		// Matmul
		"Matmul":
		{
			"prefix": ["matmul"],
			"body":
			[
				"struct matrix",
				"{",
				"    ll mat[2][2];",
				"    matrix() {memset(mat,0,sizeof(mat));}",
				"};",
				"matrix operator * (const matrix& a, const matrix& b)",
				"{",
				"    matrix c;",
				"    for (ll i = 0; i < 2; i++)",
				"    {",
				"        for (ll j = 0; j < 2; j++)",
				"        {",
				"            for (ll k = 0; k < 2; k++) c.mat[i][j] = (c.mat[i][j] + a.mat[i][k]*b.mat[k][j])%mod;",
				"        }",
				"    }",
				"    return c;",
				"}",
				"matrix bpow(const matrix& a, ll b)",
				"{",
				"    matrix t;",
				"    if (!b)" // change to if (b == 1) return a if u use min-plus matmul,
				"    {",
				"        for (ll i = 0; i < 2; i++) t.mat[i][i] = 1;",
				"        return t;",
				"    }",
				"    t = bpow(a,b/2);",
				"    if (b&1) return t*t*a;",
				"    return t*t;",
				"}"				
			]
		}	
		// Prefix Sum Merging
		"pfs_merge":
		{
			"prefix": ["pfs_merge"],
			"body":
			[
				"ll sum(const deque<ll>& a, ll p)",
				"{",
				"    if (p < 0) return 0;",
				"    if (p+1 >= (ll)a.size()) return a[0];",
				"    return a[0]-a[p+1];",
				"}",
				"void combine(deque<ll>& a, deque<ll>& b)",
				"{",
				"    if ((ll)a.size() < (ll)b.size()) swap(a,b);",
				"    for (ll i = 0; i < (ll)b.size()-1; i++) b[i] -= b[i+1];",
				"    for (ll i = 0; i < (ll)b.size(); i++) ",
				"    {",
				"        ans += b[i]*(sum(a,k2-i)-sum(a,k1-i-1));",
				"    }",
				"    for (ll i = (ll)b.size()-2; i >= 0; i--) b[i] += b[i+1];",
				"    for (ll i = 0; i < (ll)b.size(); i++) a[i] += b[i];",
				"}",
				"deque<ll> dfs(ll u, ll v)",
				"{",
				"    deque<ll> cnt; cnt.pb(1);",
				"    for (ll i : g[u])",
				"    {",
				"        if (i != v)",
				"        {",
				"            deque<ll> a = dfs(i,u);",
				"            a.pf(a.front()); combine(cnt,a);",
				"        }",
				"    }",
				"    return cnt;",
				"}"				
			]
		}
		// LCS
		"lcs":
		{
			"prefix": ["lcs"],
			"body":
			[
				"#include <bits/stdc++.h>",
				"using namespace std;",
				"typedef int ll;",
				"#define pb push_back",
				"#define pf push_front",
				"#define fi first",
				"#define se second",
				"const ll mod = 1e9+7, mxm = 1e6+7, mxn = 5e3+7;",
				"ll dp[mxn][mxn], nxt[mxm][26], m, n;",
				"string a, b;",
				"signed main()",
				"{",
				"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
				"    cin >> a >> b; m = a.size(); n = b.size(); a = '_'+a; b = '_'+b;",
				"    for (ll i = 0; i < 26; i++)",
				"    {",
				"        for (ll j = m-1; j >= 0; j--)",
				"        {",
				"            if (a[j+1]-'a' == i) nxt[j][i] = j+1;",
				"            else nxt[j][i] = nxt[j+1][i];",
				"        }",
				"    }",
				"    memset(dp,-1,sizeof(dp)); dp[0][0] = 0;",
				"    for (ll i = 0; i < n; i++)",
				"    {",
				"        for (ll j = 0; j <= i; j++)",
				"        {",
				"            if (dp[i][j] >= 0)",
				"            {",
				"                if (~dp[i+1][j]) dp[i+1][j] = min(dp[i+1][j],dp[i][j]);",
				"                else dp[i+1][j] = dp[i][j];",
				"                ll nxt_pos = nxt[dp[i][j]][b[i+1]-'a'];",
				"                if (nxt_pos)",
				"                {",
				"                    if (~dp[i+1][j+1]) dp[i+1][j+1] = min(dp[i+1][j+1],nxt_pos);",
				"                    else dp[i+1][j+1] = nxt_pos;",
				"                } ",
				"            }",
				"        }",
				"    }",
				"    ll ans = 0;",
				"    for (ll j = n; j > 0; j--) {for (ll i = j; i <= n; i++) {ans = max(ans,j*(dp[i][j] >= 0));}}",
				"    cout << ans;",
				"}"				
			]
		}
}